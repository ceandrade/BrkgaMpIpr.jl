<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · BrkgaMpIpr.jl documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="BrkgaMpIpr.jl documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit">BrkgaMpIpr.jl documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Guide / Tutorial</a></li><li><a class="tocitem" href="../license/">License</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Enumerations-1"><span>Enumerations</span></a></li><li><a class="tocitem" href="#Types-1"><span>Types</span></a></li><li><a class="tocitem" href="#I/O-functions-1"><span>I/O functions</span></a></li><li><a class="tocitem" href="#building_funcs-1"><span>Building functions</span></a></li><li><a class="tocitem" href="#Population-manipulation-functions-1"><span>Population manipulation functions</span></a></li><li><a class="tocitem" href="#Retrival-functions-1"><span>Retrival functions</span></a></li><li><a class="tocitem" href="#Evolution-functions-1"><span>Evolution functions</span></a></li><li><a class="tocitem" href="#Path-relink-functions-1"><span>Path relink functions</span></a></li><li><a class="tocitem" href="#Internals-1"><span>Internals</span></a></li><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ceandrade/BrkgaMpIpr.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-documentation-1"><a class="docs-heading-anchor" href="#API-documentation-1">API documentation</a><a class="docs-heading-anchor-permalink" href="#API-documentation-1" title="Permalink"></a></h1><h2 id="Enumerations-1"><a class="docs-heading-anchor" href="#Enumerations-1">Enumerations</a><a class="docs-heading-anchor-permalink" href="#Enumerations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.BiasFunction" href="#BrkgaMpIpr.BiasFunction"><code>BrkgaMpIpr.BiasFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@enum BiasFunction</code></pre><p>Specifies a bias function when choosing parents to mating. This function substitutes the <span>$\rho$</span> (rho) parameter from the original BRKGA. For a given rank <span>$r$</span>, we have the following functions:</p><ul><li><p><code>CONSTANT</code>: 1 / number of parents for mating (all individuals have the             same probability)</p></li><li><p><code>CUBIC</code>: <span>$r^{-3}$</span></p></li><li><p><code>EXPONENTIAL</code>: <span>$ϵ^{-r}$</span></p></li><li><p><code>LINEAR</code>: <span>$1 / r$</span></p></li><li><p><code>LOGINVERSE</code>: <span>$1 / \log(r + 1)$</span></p></li><li><p><code>QUADRATIC</code>: <span>$r^{-2}$</span></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/46ce4d79337bdd257ee2e3d2f4bb1c55ff0a5030/base/#L0-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.PathRelinkingResult" href="#BrkgaMpIpr.PathRelinkingResult"><code>BrkgaMpIpr.PathRelinkingResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@enum PathRelinkingResult</code></pre><p>Specifies the result type/status of path relink procedure:</p><ul><li><p><code>TOO_HOMOGENEOUS</code>: the chromosomes among the populations are too homogeneous                    and the path relink will not generate improveded                    solutions.</p></li><li><p><code>NO_IMPROVEMENT</code>: path relink was done but no improveded solution was found.</p></li><li><p><code>ELITE_IMPROVEMENT</code>: an improved solution among the elite set was found,                      but the best solution was not improved.</p></li><li><p><code>BEST_IMPROVEMENT</code>: the best solution was improved.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/46ce4d79337bdd257ee2e3d2f4bb1c55ff0a5030/base/#L0-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.PathRelinkingSelection" href="#BrkgaMpIpr.PathRelinkingSelection"><code>BrkgaMpIpr.PathRelinkingSelection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@enum PathRelinkingSelection</code></pre><p>Specifies which individuals used to build the path:</p><ul><li><p><code>BESTSOLUTION</code>: selects, in the order, the best solution of each population.</p></li><li><p><code>RANDOMELITE</code>: chooses uniformly random solutions from the elite sets.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/46ce4d79337bdd257ee2e3d2f4bb1c55ff0a5030/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.PathRelinkingType" href="#BrkgaMpIpr.PathRelinkingType"><code>BrkgaMpIpr.PathRelinkingType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@enum PathRelinkingType</code></pre><p>Specifies type of path relinking:</p><ul><li><p><code>DIRECT</code>: changes each key for the correspondent in the other chromosome.</p></li><li><p><code>PERMUTATION</code>: switches the order of a key for that in the other chromosome.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/46ce4d79337bdd257ee2e3d2f4bb1c55ff0a5030/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.Sense" href="#BrkgaMpIpr.Sense"><code>BrkgaMpIpr.Sense</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@enum Sense</code></pre><p>Tells the algorithm either to <code>MINIMIZE</code> or <code>MAXIMIZE</code> the objective function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/46ce4d79337bdd257ee2e3d2f4bb1c55ff0a5030/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.ShakingType" href="#BrkgaMpIpr.ShakingType"><code>BrkgaMpIpr.ShakingType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@enum ShakingType</code></pre><p>Specifies the type of shaking to be performed.</p><ul><li><p><code>CHANGE</code>: applies the following perturbations:</p><ol><li>Inverts the value of a random chosen, i.e., from <code>value</code> to <code>1 - value</code>;</li><li>Assigns a random value to a random key.</li></ol></li><li><p><code>SWAP</code>: applies two swap perturbations:</p><ol><li>Swaps the values of a randomly chosen key <code>i</code> and its neighbor <code>i + 1</code>;</li><li>Swaps values of two randomly chosen keys.</li></ol></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/46ce4d79337bdd257ee2e3d2f4bb1c55ff0a5030/base/#L0-L14">source</a></section></article><h2 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.AbstractInstance" href="#BrkgaMpIpr.AbstractInstance"><code>BrkgaMpIpr.AbstractInstance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractInstance</code></pre><p>The required interface for external data to be provided to the decoder. The problem definitions and data <strong>must be</strong> a subtype of AbstractInstance. For example,</p><pre><code class="language-julia">mutable struct TSPInstance &lt;: AbstractInstance
    num_cities::Int64
    distances::Array{Float64}
end</code></pre><p>represents an instance type for the Traveling Salesman problem which defines the number fo cities and a matrix of distances between them.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.BrkgaData" href="#BrkgaMpIpr.BrkgaData"><code>BrkgaMpIpr.BrkgaData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct BrkgaData</code></pre><p>Represents the internal state of the BRKGA-MP-IPR algorithm.</p><p>This structure has no direct constructor and must be built using <a href="#BrkgaMpIpr.build_brkga"><code>build_brkga</code></a> functions. You can create multiple <code>BrkgaData</code> representing different states of the algorithm, and use them independently.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This structure is <strong>NOT INTENDED</strong> to be used outside BRKGA functions. Ad hoc changes may lead to inadvertent results.</p></div></div><p><strong>Fields</strong></p><ul><li><p><code>opt_sense</code></p><p>Optimization sense (minimization = 0, maximization = 1).</p></li></ul><ul><li><p><code>chromosome_size</code></p><p>Number of genes in the chromosome [&gt; 0].</p></li></ul><ul><li><p><code>params</code></p><p>BRKGA parameters for evolution.</p></li></ul><ul><li><p><code>elite_size</code></p><p>Number of elite items in the population [&gt; 0].</p></li></ul><ul><li><p><code>num_mutants</code></p><p>Number of mutants introduced at each generation into the population [&gt; 0].</p></li></ul><ul><li><p><code>evolutionary_mechanism_on</code></p><p>If false, no evolution is performed but only chromosome decoding. Very useful to emulate a multi-start algorithm.</p></li></ul><ul><li><p><code>problem_instance</code></p><p><em>(Internal data)</em> The problem instance used by the <code>decode!</code> function to map a chromosome to a problem solution. Since <code>decode!</code> should not change this data, this attribute can be considered constant.</p></li></ul><ul><li><p><code>decode!</code></p><p><em>(Internal data)</em> This is the <strong>main decode function</strong> called during the evolutionary process and in the path relink. It <strong>must have</strong> the following signature:</p><pre><code class="language-julia">decode!(chromosome::Array{Float64, 1},
        problem_instance::AbstractInstance,
        rewrite::Bool = true)::Float64</code></pre><p>Note that if <code>rewrite == false</code>, <code>decode!</code> must not change <code>chromosome</code>. IPR routines requires <code>decode!</code> to not change <code>chromosome</code>.</p></li></ul><ul><li><p><code>rng</code></p><p><em>(Internal data)</em> The internal random generator number. DON&#39;T USE FOR ANYTHING OUTSIDE. If you need a RNG, create a new generator.</p></li></ul><ul><li><p><code>previous</code></p><p><em>(Internal data)</em> Previous population.</p></li></ul><ul><li><p><code>current</code></p><p><em>(Internal data)</em> Current population.</p></li></ul><ul><li><p><code>bias_function</code></p><p><em>(Internal data)</em> A unary non-increasing function such that <code>bias_function(::Int64 &gt; 0)::Float64</code></p></li></ul><ul><li><p><code>total_bias_weight</code></p><p><em>(Internal data)</em> Holds the sum of the results of each raking given a bias function. This value is needed to normalization.</p></li></ul><ul><li><p><code>shuffled_individuals</code></p><p><em>(Internal data)</em> Used to shuffled individual/chromosome indices during the mate.</p></li></ul><ul><li><p><code>parents_ordered</code></p><p><em>(Internal data)</em> Defines the order of parents during the mating.</p></li></ul><ul><li><p><code>initialized</code></p><p><em>(Internal data)</em> Indicates if the algorithm was proper initialized.</p></li></ul><ul><li><p><code>reset_phase</code></p><p><em>(Internal data)</em> Indicates if the algorithm have been reset.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.BrkgaParams" href="#BrkgaMpIpr.BrkgaParams"><code>BrkgaMpIpr.BrkgaParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct BrkgaParams</code></pre><p>Represents the BRKGA and IPR hyper-parameters. You can load these parameters from a configuration file using <a href="#BrkgaMpIpr.load_configuration"><code>load_configuration</code></a> and <a href="#BrkgaMpIpr.build_brkga"><code>build_brkga</code></a>, and write them using <a href="#BrkgaMpIpr.write_configuration"><code>write_configuration</code></a>.</p><p><strong>Fields</strong></p><ul><li><p><code>population_size</code></p><p>Number of elements in the population [&gt; 0].</p></li></ul><ul><li><p><code>elite_percentage</code></p><p>Percentage of individuals to become the elite set (0, 1].</p></li></ul><ul><li><p><code>mutants_percentage</code></p><p>Percentage of mutants to be inserted in the population</p></li></ul><ul><li><p><code>num_elite_parents</code></p><p>Number of elite parents for mating [&gt; 0].</p></li></ul><ul><li><p><code>total_parents</code></p><p>Number of total parents for mating [&gt; 0].</p></li></ul><ul><li><p><code>bias_type</code></p><p>Type of bias that will be used.</p></li></ul><ul><li><p><code>num_independent_populations</code></p><p>Number of independent parallel populations.</p></li></ul><ul><li><p><code>pr_number_pairs</code></p><p>Number of pairs of chromosomes to be tested to path relinking.</p></li></ul><ul><li><p><code>pr_minimum_distance</code></p><p>Mininum distance between chromosomes selected to path-relinking.</p></li></ul><ul><li><p><code>pr_type</code></p><p>Path relinking type.</p></li></ul><ul><li><p><code>pr_selection</code></p><p>Individual selection to path-relinking.</p></li></ul><ul><li><p><code>alpha_block_size</code></p><p>Defines the block size based on the size of the population.</p></li></ul><ul><li><p><code>pr_percentage</code></p><p>Percentage / path size to be computed. Value in (0, 1].</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.ExternalControlParams" href="#BrkgaMpIpr.ExternalControlParams"><code>BrkgaMpIpr.ExternalControlParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ExternalControlParams</code></pre><p>Represents additional control parameters that can be used outside this framework. You can load these parameters from a configuration file using <a href="#BrkgaMpIpr.load_configuration"><code>load_configuration</code></a> and <a href="#BrkgaMpIpr.build_brkga"><code>build_brkga</code></a>, and write them using <a href="#BrkgaMpIpr.write_configuration"><code>write_configuration</code></a>.</p><p><strong>Fields</strong></p><ul><li><p><code>exchange_interval</code></p><p>Interval at which elite chromosomes are exchanged (0 means no exchange) [&gt; 0].</p></li></ul><ul><li><p><code>num_exchange_indivuduals</code></p><p>Number of elite chromosomes exchanged from each population [&gt; 0].</p></li></ul><ul><li><p><code>reset_interval</code></p><p>Interval at which the populations are reset (0 means no reset) [&gt; 0].</p></li></ul></div></section></article><h2 id="I/O-functions-1"><a class="docs-heading-anchor" href="#I/O-functions-1">I/O functions</a><a class="docs-heading-anchor-permalink" href="#I/O-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.parse" href="#Base.parse"><code>Base.parse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parse(::Type{BiasFunction}, value::String)::BiasFunction</code></pre><p>Parse <code>value</code> returning a valid <a href="#BrkgaMpIpr.BiasFunction"><code>BiasFunction</code></a> enumeration.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: in case the bias description does not match.</li></ul></div></section><section><div><pre><code class="language-none">parse(::Type{PathRelinkingType}, value::String)::PathRelinkingType</code></pre><p>Parse <code>value</code> returning a valid <a href="#BrkgaMpIpr.PathRelinkingType"><code>PathRelinkingType</code></a> enumeration.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: in case the type description does not match.</li></ul></div></section><section><div><pre><code class="language-none">parse(::Type{PathRelinkingSelection}, value::String)::PathRelinkingSelection</code></pre><p>Parse <code>value</code> returning a valid <a href="#BrkgaMpIpr.PathRelinkingSelection"><code>PathRelinkingSelection</code></a> enumeration.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: in case the selection description does not match.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.load_configuration" href="#BrkgaMpIpr.load_configuration"><code>BrkgaMpIpr.load_configuration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_configuration(configuration_file::String)::
        Tuple{BrkgaParams, ExternalControlParams}</code></pre><p>Load the parameters from <code>configuration_file</code> returning them as a tuple.</p><p><strong>Throws</strong></p><ul><li><code>LoadError</code>: in cases of the file is an invalid configuration file, parameters are missing, or parameters are ill-formatted.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.write_configuration" href="#BrkgaMpIpr.write_configuration"><code>BrkgaMpIpr.write_configuration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function write_configuration(filename::String, brkga_params::BrkgaParams,
                             external_params::ExternalControlParams)</code></pre><p>Write <code>brkga_params</code> and <code>external_params</code> into <code>filename</code>.</p><p><strong>Throws</strong></p><ul><li><code>SystemError</code>: in case the configuration files cannot be openned.</li></ul></div></section><section><div><pre><code class="language-none">function write_configuration(filename::String, brkga_data::BrkgaData,
                             external_params::ExternalControlParams =
                                                    ExternalControlParams())</code></pre><p>Write the parameters from <code>brkga_data.params</code> and <code>external_params</code> into <code>filename</code>.</p><p><strong>Throws</strong></p><ul><li><code>SystemError</code>: in case the configuration files cannot be openned.</li></ul></div></section></article><h2 id="building_funcs-1"><a class="docs-heading-anchor" href="#building_funcs-1">Building functions</a><a class="docs-heading-anchor-permalink" href="#building_funcs-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.build_brkga" href="#BrkgaMpIpr.build_brkga"><code>BrkgaMpIpr.build_brkga</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_brkga(problem_instance::AbstractInstance, decode_function!::Function,
            opt_sense::Sense, seed::Int64, chromosome_size::Int64,
            brkga_params::BrkgaParams, evolutionary_mechanism_on::Bool = true,
)::BrkgaData</code></pre><p>Build a <a href="#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> object to be used in the evolutionary and path relink procedures. Such data structure should not be changed outside the <code>BrkgaMpIpr</code> functions. This version accepts all control arguments, and it is handy for tuning purposes.</p><p><strong>Arguments</strong></p><ul><li><p><a href="#BrkgaMpIpr.AbstractInstance"><code>problem_instance::AbstractInstance</code></a>: an instance to the problem to be solved.</p></li><li><p><code>decode_function!::Function</code>: the decode funtion used to map chromosomes to solutions. It <strong>must have</strong> the following signature:</p><pre><code class="language-julia">decode!(chromosome::Array{Float64, 1},
        problem_instance::AbstractInstance,
        rewrite::Bool)::Float64</code></pre><p>Note that if <code>rewrite == false</code>, <code>decode!</code> cannot modify <code>chromosome</code>.</p></li><li><p><a href="#BrkgaMpIpr.Sense"><code>opt_sense::Sense</code></a>: the optimization sense ( maximization or minimization).</p></li><li><p><code>seed::Int64</code>: seed for the random number generator.</p></li><li><p><code>chromosome_size::Int64</code>: number of genes in each chromosome.</p></li><li><p><a href="#BrkgaMpIpr.BrkgaParams"><code>brkga_params::BrkgaParams</code></a>: BRKGA and IPR parameters object loaded from a configuration file or manually created. All the data is deep-copied.</p></li><li><p><code>evolutionary_mechanism_on::Bool = true</code>: if false, no evolution is performed but only chromosome decoding. On each generation, all population is replaced excluding the best chromosome. Very useful to emulate a multi-start algorithm.</p></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: in several cases where the arguments or a combination of them are invalid.</li></ul></div></section><section><div><pre><code class="language-none">build_brkga(problem_instance, decode_function!, opt_sense, seed,
    chromosome_size, configuration_file,
    evolutionary_mechanism_on)::Tuple{BrkgaData, ExternalControlParams}</code></pre><p>Build a <a href="#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> object to be used in the evolutionary and path relink procedures, and a <a href="#BrkgaMpIpr.ExternalControlParams"><code>ExternalControlParams</code></a> that holds additional control parameters. Note that <a href="#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> should not be changed outside the <code>BrkgaMpIpr</code> functions. This version reads most of the parameters from a configuration file.</p><p><strong>Arguments</strong></p><ul><li><p><a href="#BrkgaMpIpr.AbstractInstance"><code>problem_instance::AbstractInstance</code></a>: an instance to the problem to be solved.</p></li><li><p><code>decode_function!::Function</code>: the decode funtion used to map chromosomes to solutions. It <strong>must have</strong> the following signature:</p><pre><code class="language-julia">decode!(chromosome::Array{Float64, 1},
        problem_instance::AbstractInstance,
        rewrite::Bool = true)::Float64</code></pre><p>Note that if <code>rewrite == false</code>, <code>decode!</code> cannot modify <code>chromosome</code>.</p></li><li><p><a href="#BrkgaMpIpr.Sense"><code>opt_sense::Sense</code></a>: the optimization sense ( maximization or minimization).</p></li><li><p><code>seed::Int64</code>: seed for the random number generator.</p></li><li><p><code>chromosome_size::Int64</code>: number of genes in each chromosome..</p></li><li><p><code>configuration_file::String</code>:  text file with the BRKGA parameters. An example can be found at &lt;a href=&quot;example.conf&quot;&gt;example.conf&lt;/a&gt;. Note that the content after &quot;#&quot; is considered comments and it is ignored.</p></li><li><p><code>evolutionary_mechanism_on::Bool = true</code>: if false, no evolution is performed but only chromosome decoding. On each generation, all population is replaced excluding the best chromosome. Very useful to emulate a multi-start algorithm.</p></li></ul><p><strong>Throws</strong></p><ul><li><code>LoadError</code>: in cases of the file is an invalid configuration file, parameters are missing, or parameters are ill-formatted.</li><li><code>SystemError</code>: in case the configuration files cannot be openned.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.initialize!" href="#BrkgaMpIpr.initialize!"><code>BrkgaMpIpr.initialize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">initialize!(brkga_data::BrkgaData)</code></pre><p>Initialize the populations and others data structures of the BRKGA. If an initial population is supplied, this method completes the remaining individuals, if they do not exist.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>THIS METHOD MUST BE CALLED BEFORE ANY OPTIMIZATION METHODS.</p></div></div><p>This method also performs the initial decoding of the chromosomes. Therefore, depending on the decoder implementation, this can take a while, and the user may want to time such procedure in his/her experiments.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>As it is in <a href="#BrkgaMpIpr.evolve!"><code>evolve!</code></a>, the decoding is done in parallel using threads, and the user <strong>must guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be held, we suggest using a single thread by setting the environmental variable <code>JULIA_NUM_THREADS = 1</code> <a href="https://docs.julialang.org/en/v1.1/manual/parallel-computing/">(see Julia Parallel Computing)</a>.</p></div></div><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <code>bias_function</code> is not defined previously.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.set_bias_custom_function!" href="#BrkgaMpIpr.set_bias_custom_function!"><code>BrkgaMpIpr.set_bias_custom_function!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_bias_custom_function!(brkga_data::BrkgaData, bias_function::Function)</code></pre><p>Set a new bias function to be used to rank the chromosomes during the mating. <strong>It must be a positive non-increasing function</strong> returning a Float64, i.e., <code>f(::Int64)::Float64</code> such that <code>f(i) ≥ 0</code> and <code>f(i) ≥ f(i+1)</code> for <code>i ∈ [1..total_parents]</code>. For instance, the following sets an inverse quadratic function:</p><pre><code class="language-julia">set_bias_custom_function!(brkga_data, x -&gt; 1.0 / (x * x))</code></pre><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: in case the function is not a non-increasing positive function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.set_initial_population!" href="#BrkgaMpIpr.set_initial_population!"><code>BrkgaMpIpr.set_initial_population!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_initial_population!(brkga_data::BrkgaData,
                        chromosomes::Array{Array{Float64, 1}, 1})</code></pre><p>Set initial individuals into the poulation to work as warm-starters. Such individuals can be obtained from solutions of external procedures such as fast heuristics, other methaheuristics, or even relaxations from a mixed integer programming model that models the problem.</p><p>All given solutions are assigned to one population only. Therefore, the maximum number of solutions is the size of the populations.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: if the number of given chromosomes is larger than the population size; if the sizes of the given chromosomes do not match with the required chromosome size.</li></ul></div></section></article><h2 id="Population-manipulation-functions-1"><a class="docs-heading-anchor" href="#Population-manipulation-functions-1">Population manipulation functions</a><a class="docs-heading-anchor-permalink" href="#Population-manipulation-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.exchange_elite!" href="#BrkgaMpIpr.exchange_elite!"><code>BrkgaMpIpr.exchange_elite!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">exchange_elite!(brkga_data::BrkgaData, num_immigrants::Int64)</code></pre><p>Exchange elite-solutions between the populations. Given a population, the <code>num_immigrants</code> best solutions are copied to the neighbor populations, replacing their worth solutions. If there is only one population, nothing is done.</p><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <a href="#BrkgaMpIpr.initialize!"><code>initialize!</code></a> has not been called before.</li><li><code>ArgumentError</code>: when <code>num_immigrants &lt; 1</code>.</li><li><code>ArgumentError</code>: <code>num_immigrants ≥ ⌈population_size/num_independent_populations⌉ - 1</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.inject_chromosome!" href="#BrkgaMpIpr.inject_chromosome!"><code>BrkgaMpIpr.inject_chromosome!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function inject_chromosome!(brkga_data::BrkgaData,
                            chromosome::Array{Float64, 1},
                            population_index::Int64,
                            position::Int64,
                            fitness::Float64 = Inf)</code></pre><p>Inject <code>chromosome</code> and its <code>fitness</code> into population <code>population_index</code> in the <code>position</code> place. If fitness is not provided (<code>fitness = Inf</code>), the decoding is performed over <code>chromosome</code>. Once the chromosome is injected, the population is re-sorted according to the chromosomes&#39; fitness.</p><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <a href="#BrkgaMpIpr.initialize!"><code>initialize!</code></a> has not been called before.</li><li><code>ArgumentError</code>: when <code>population_index &lt; 1</code> or <code>population_index &gt; num_independent_populations</code>.</li><li><code>ArgumentError</code>: when <code>position &lt; 1</code> or <code>position &gt; population_size</code>.</li><li><code>ArgumentError</code>: when <code>lenght(chromosome) != chromosome_size</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.reset!" href="#BrkgaMpIpr.reset!"><code>BrkgaMpIpr.reset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reset!(brkga_data::BrkgaData)</code></pre><p>Reset all populations with brand new keys. All warm-start solutions provided by <a href="#BrkgaMpIpr.set_initial_population!"><code>set_initial_population!</code></a> are discarded. You may use <a href="#BrkgaMpIpr.inject_chromosome!"><code>inject_chromosome!</code></a> to insert those solutions again.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>As it is in <a href="#BrkgaMpIpr.evolve!"><code>evolve!()</code></a>, the decoding is done in parallel using threads, and the user <strong>must guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be held, we suggest using single thread by setting the environmental variable <code>JULIA_NUM_THREADS = 1</code> <a href="https://docs.julialang.org/en/v1.1/manual/parallel-computing/">(see Julia Parallel Computing)</a></p></div></div><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <a href="#BrkgaMpIpr.initialize!"><code>initialize!</code></a> has not been called before.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.shake!" href="#BrkgaMpIpr.shake!"><code>BrkgaMpIpr.shake!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function shake!(brkga_data::BrkgaData, intensity::Int64,
                shaking_type::ShakingType, population_index::Int64 = Inf64)</code></pre><p>Perform a shaking in the chosen population. The procedure applies changes (shaking) on elite chromosomes and fully reset the remaining population.</p><p><strong>Arguments</strong></p><ul><li><code>intensity::Int64</code>: the intensity of the shaking (&gt; 0);</li><li><a href="#BrkgaMpIpr.ShakingType"><code>shaking_type::ShakingType</code></a>: either <code>CHANGE</code> or <code>SWAP</code> moves;</li><li><code>population_index::Int64</code>: the index of the population to be shaken. If <code>population_index &gt; num_independent_populations</code>, all populations are shaken.</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <a href="#BrkgaMpIpr.initialize!"><code>initialize!</code></a> has not been called before.</li><li><code>ArgumentError</code>: when <code>population_index &lt; 1</code> or <code>intensity &lt; 1</code>.</li></ul></div></section></article><h2 id="Retrival-functions-1"><a class="docs-heading-anchor" href="#Retrival-functions-1">Retrival functions</a><a class="docs-heading-anchor-permalink" href="#Retrival-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.get_best_chromosome" href="#BrkgaMpIpr.get_best_chromosome"><code>BrkgaMpIpr.get_best_chromosome</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_best_chromosome(brkga_data::BrkgaData)::Array{Float64, 1}</code></pre><p>Return a copy of the best individual found so far among all populations.</p><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <a href="#BrkgaMpIpr.initialize!"><code>initialize!</code></a> has not been called before.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.get_best_fitness" href="#BrkgaMpIpr.get_best_fitness"><code>BrkgaMpIpr.get_best_fitness</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_best_fitness!(brkga_data::BrkgaData)::Float64</code></pre><p>Return the fitness/value of the best individual found so far among all populations.</p><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <a href="#BrkgaMpIpr.initialize!"><code>initialize!</code></a> has not been called before.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.get_chromosome" href="#BrkgaMpIpr.get_chromosome"><code>BrkgaMpIpr.get_chromosome</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_chromosome(brkga_data::BrkgaData, population_index::Int64,
               position::Int64)::Array{Float64, 1}</code></pre><p>Return a copy of the chromosome ranked at <code>position</code> in the population <code>population_index</code>. Note that the chromosomes are rakend by fitness and the best chromosome is located in position 1.</p><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <a href="#BrkgaMpIpr.initialize!"><code>initialize!</code></a> has not been called before.</li><li><code>ArgumentError</code>: when <code>population_index &lt; 1</code> or <code>population_index &gt; num_independent_populations</code>.</li><li><code>ArgumentError</code>: when <code>position &lt; 1</code> or <code>position &gt; population_size</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.get_current_population" href="#BrkgaMpIpr.get_current_population"><code>BrkgaMpIpr.get_current_population</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_current_population(brkga_data::BrkgaData,
                       population_index::Int64)::Population</code></pre><p>Return a reference for population <code>population_index</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is implemented for complaince with the C++ API. The user can access the population directly using <code>brkga_data.current[population_index]</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>IT IS NOT ADIVISED TO CHANGE THE POPULATION DIRECTLY, since such changes can result in undefined behavior.</p></div></div><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <a href="#BrkgaMpIpr.initialize!"><code>initialize!</code></a> has not been called before.</li><li><code>ArgumentError</code>: when <code>population_index &lt; 1</code> or <code>population_index &gt; num_independent_populations</code>.</li></ul></div></section></article><h2 id="Evolution-functions-1"><a class="docs-heading-anchor" href="#Evolution-functions-1">Evolution functions</a><a class="docs-heading-anchor-permalink" href="#Evolution-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.evolve!" href="#BrkgaMpIpr.evolve!"><code>BrkgaMpIpr.evolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evolve!(brkga_data::BrkgaData, num_generations::Int64 = 1)</code></pre><p>Evolve the current populations following the guidelines of Multi-parent BRKGAs for <code>num_generations</code> generations.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The decoding is done in parallel using threads, and the user <strong>must guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be held, we suggest using single thread by setting the environmental variable <code>JULIA_NUM_THREADS = 1</code> <a href="https://docs.julialang.org/en/v1.1/manual/parallel-computing/">(see Julia Parallel Computing)</a>.</p></div></div><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <a href="#BrkgaMpIpr.initialize!"><code>initialize!()</code></a> was not called before.</li><li><code>ArgumentError</code>: when <code>num_generations &lt; 1</code>.</li></ul></div></section></article><h2 id="Path-relink-functions-1"><a class="docs-heading-anchor" href="#Path-relink-functions-1">Path relink functions</a><a class="docs-heading-anchor-permalink" href="#Path-relink-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.affect_solution_hamming_distance" href="#BrkgaMpIpr.affect_solution_hamming_distance"><code>BrkgaMpIpr.affect_solution_hamming_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">affect_solution_hamming_distance(block1::SubArray{Float64, 1},
                                 block2::SubArray{Float64, 1},
                                 threshold::Float64 = 0.5)::Bool</code></pre><p>Return <code>true</code> the the changing of the blocks of keys <code>block1</code> by the blocks of keys <code>block2</code> affects the solution, based on the <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function may be more appropriated to threshold/direct chromosome representations.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>block1</code> and <code>block2</code> must have the same size. No bounds checking is done due to performance reasons.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is annotated with <code>@inline</code> due to performance reasons too.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>block1::SubArray{Float64, 1}</code>: the first vector.</li><li><code>block2::SubArray{Float64, 1}</code>: the second vector.</li><li><code>threshold::Float64 = 0.5</code>: the threshold for binarization.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.affect_solution_kendall_tau" href="#BrkgaMpIpr.affect_solution_kendall_tau"><code>BrkgaMpIpr.affect_solution_kendall_tau</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">affect_solution_kendall_tau(block1::SubArray{Float64, 1},
                            block2::SubArray{Float64, 1})::Bool</code></pre><p>Return <code>true</code> the the changing of the blocks of keys <code>block1</code> by the blocks of keys <code>block2</code> affects the solution, based on the <a href="https://en.wikipedia.org/wiki/Kendall_tau_distance">Kendall Tau distance.</a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>block1</code> and <code>block2</code> must have the same size. No bounds checking is done due to performance reasons.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>block1::SubArray{Float64, 1}</code>: the first vector.</li><li><code>block2::SubArray{Float64, 1}</code>: the second vector.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.hamming_distance" href="#BrkgaMpIpr.hamming_distance"><code>BrkgaMpIpr.hamming_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hamming_distance(vector1::Array{Float64, 1}, vector2::Array{Float64, 1},
                 threshold::Float64 = 0.5)::Float64</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a> between two vectors. It takes a <code>threshold</code> parameter to &quot;binarize&quot; the vectors. For instance, if <code>threshold = 0.7</code>, all values larger than or equal to 0.7 will be considerd <code>1.0</code>, otherwise <code>0.0</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function may be more appropriated to threshold/direct chromosome representations.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>vector1::Array{Float64, 1}</code>: the first vector.</li><li><code>vector2::Array{Float64, 1}</code>: the second vector.</li><li><code>threshold::Float64 = 0.5</code>: the threshold for binarization.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: if <code>vector1</code> and <code>vector2</code> have different sizes.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.kendall_tau_distance" href="#BrkgaMpIpr.kendall_tau_distance"><code>BrkgaMpIpr.kendall_tau_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kendall_tau_distance(vector1::Array{Float64, 1},
                     vector2::Array{Float64, 1};
                     stop_immediately::Bool = false)::Float64

kendall_tau_distance(vector1::SubArray{Float64, 1},
                     vector2::SubArray{Float64, 1};
                     stop_immediately::Bool = false)::Float64</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Kendall_tau_distance">Kendall Tau distance</a> between two vectors.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function may be more appropriated to permutation chromosome representations.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>vector1::Array{Float64, 1}</code>: the first vector.</li><li><code>vector2::Array{Float64, 1}</code>: the second vector.</li><li><code>stop_immediately::Bool = false</code>: if <code>true</code>, stop the computation immediately after find a difference.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: if <code>vector1</code> and <code>vector2</code> have different sizes.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.path_relink!" href="#BrkgaMpIpr.path_relink!"><code>BrkgaMpIpr.path_relink!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function path_relink!(brkga_data::BrkgaData,
    pr_type::PathRelinkingType,
    pr_selection::PathRelinkingSelection,
    compute_distance::Function,
    affect_solution::Function,
    number_pairs::Int64,
    minimum_distance::Float64,
    block_size::Int64,
    max_time::Float64,
    percentage::Float64
)::PathRelinkingResult</code></pre><p>Perform path relinking between elite solutions that are, at least, a given minimum distance between themselves.</p><p>In the presence of multiple populations, the path relinking is performed between elite chromosomes from different populations, in a circular fashion. For example, suppose we have 3 populations. The framework performs 3 path relinkings: the first between individuals from populations 1 and 2, the second between populations 2 and 3, and the third between populations 3 and 1. In the case of just one population, both base and guiding individuals are sampled from the elite set of that population.</p><p>Note that the algorithm tries to find a pair of base and guiding solutions with a minimum distance given by the distance function. If this is not possible, a new pair of solutions are sampled (without replacement) and tested against the distance. In case it is not possible to find such pairs for the given populations, the algorithm skips to the next pair of populations (in a circular fashion, as described above). Yet, if such pairs are not found in any case, the algorithm declares failure. This indicates that the populations are very homogeneous.</p><p>If the found solution is the best solution found so far, IPR replaces the worst solution by it. Otherwise, IPR computes the distance between the found solution and all other solutions in the elite set, and replaces the worst solution by it if and only if the found solution is, at least, <code>minimum_distance</code> from all them.</p><p>The API will call <code>decode!()</code> function always with <code>writeback = false</code>. The reason is that if the decoder rewrites the chromosome, the path between solutions is lost and inadvertent results may come up. Note that at the end of the path relinking, the method calls the decoder with <code>writeback = true</code> in the best chromosome found to guarantee that this chromosome is re-written to reflect the best solution found.</p><p>This method is a multi-thread implementation. Instead of to build and decode each chromosome one at a time, the method builds a list of candidates, altering the alleles/keys according to the guide solution, and then decode all candidates in parallel. Note that <code>O(chromosome_size^2 / block_size)</code> additional memory is necessary to build the candidates, which can be costly if the <code>chromosome_size</code> is very large.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>As it is in <a href="#BrkgaMpIpr.evolve!"><code>evolve!()</code></a>, the decoding is done in parallel using threads, and the user <strong>must guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be held, we suggest using single thread by setting the environmental variable <code>JULIA_NUM_THREADS = 1</code> <a href="https://docs.julialang.org/en/v1.1/manual/parallel-computing/">(see Julia Parallel Computing)</a>.</p></div></div><p><strong>Arguments</strong></p><ul><li><p><a href="#BrkgaMpIpr.BrkgaData"><code>brkga_data::BrkgaData</code></a>: the BRKGA data.</p></li><li><p><a href="#BrkgaMpIpr.PathRelinkingType"><code>pr_type::PathRelinkingType</code></a>: type of path relinking to be performed. Either <code>DIRECT</code> or <code>PERMUTATION</code>-based.</p></li><li><p><a href="#BrkgaMpIpr.PathRelinkingSelection"><code>pr_selection::PathRelinkingSelection</code></a>: selection of which individuals use to path relinking. Either <code>BESTSOLUTION</code> or <code>RANDOMELITE</code>.</p></li><li><p><code>compute_distance::Function</code>: the function used to compute the distance between two chromosomes. The function <strong>MUST HAVE</strong> the following signature</p><pre><code class="language-julia">compute_distance(vector1::Array{Float64, 1},
                 vector2::Array{Float64, 1})::Float64</code></pre></li><li><p><code>affect_solution::Function</code>: function that takes two partial chromosomes / block of genes <code>block1</code> and <code>block2</code> and checks whether changing the keys from <code>block1</code> to <code>block2</code> affects the solution. For instance, suppose that the alleles/keys are used as threshold such that values &gt; 0.5 activate a feature. Suppose we have <code>block1 = [0.3, 0.4, 0.1]</code> and <code>block2 = [0.4, 0.1, 0.2]</code>. Since all values are below 0.5, changing the keys from <code>block1</code> to <code>block2</code> do not change the solution, and therefore, we can drop such change (and subsequentely decoding). The blocks can hold only one key/allele, sequential key blocks, or even the whole chromosome. <code>affect_solution</code> takes two views/subarrays. The function <strong>MUST HAVE</strong> the following signature</p><pre><code class="language-julia">affect_solution(block1::SubArray{Float64, 1},
                block2::SubArray{Float64, 1})::Bool</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function depends on the problem structure and how the   keys/alleles are used</p></div></div></li><li><p><code>number_pairs::Int64</code>: number of chromosome pairs to be tested.  If <code>number_pairs &lt; 1</code>, all pairs are tested.</p></li><li><p><code>minimum_distance::Float64</code>: minimum distance between two chromosomes computed by <code>compute_distance</code>.</p></li><li><p><code>block_size::Int64 = 1</code>: number of alleles to be exchanged at once in each iteration. If one, the traditional path relinking is performed. It must be ≥ 1.</p></li><li><p><code>max_time::Float64 = 0</code>: abort path-relinking when reach <code>max_time</code>. If <code>max_time ≤ 0</code>, no limit is imposed. Given in seconds.</p></li><li><p><code>percentage::Float64 = 1.0</code>: define the size, in percentage, of the path to build. Range [0, 1].</p></li></ul><p><strong>Returns</strong></p><ul><li>Returns <a href="#BrkgaMpIpr.PathRelinkingResult"><code>PathRelinkingResult</code></a> depending on the relink status.</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <a href="#BrkgaMpIpr.initialize!"><code>initialize!()</code></a> was not called before.</li><li><code>ArgumentError</code>: when <code>percentage &lt; 1e-6 || percentage &gt; 1.0</code> and <code>block_size &lt; 1</code>.</li></ul></div></section></article><h2 id="Internals-1"><a class="docs-heading-anchor" href="#Internals-1">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-1" title="Permalink"></a></h2><p>These types and functions are used internally in the framework. They are not meant to be used directly.</p><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.DecodeStruct" href="#BrkgaMpIpr.DecodeStruct"><code>BrkgaMpIpr.DecodeStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct DecodeStruct</code></pre><p>Hold the data structures used to build a candidate chromosome for parallel decoding on permutation-based path relink.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>THIS IS AN INTERNAL DATA STRUCTURE AND IT IS NOT MEANT TO BE USED DIRECTLY.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.Population" href="#BrkgaMpIpr.Population"><code>BrkgaMpIpr.Population</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Population (internal BRKGA data struct)</code></pre><p>Encapsulates a population of chromosomes. Note that this struct is <strong>NOT</strong> meant to be used externally of this unit.</p><p><strong>Fields</strong></p><ul><li><p><code>chromosomes</code></p><p>Population of chromosomes.</p></li></ul><ul><li><p><code>fitness</code></p><p>Fitness of a each chromosome. Each pair represents the fitness and the chromosome index.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.Triple" href="#BrkgaMpIpr.Triple"><code>BrkgaMpIpr.Triple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Triple</code></pre><p>Hold the data structures used to build a candidate chromosome for parallel decoding on direct path relink.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>THIS IS AN INTERNAL DATA STRUCTURE AND IT IS NOT MEANT TO BE USED DIRECTLY.</p></div></div></div></section></article><h3 id="Minor-helper-functions-1"><a class="docs-heading-anchor" href="#Minor-helper-functions-1">Minor helper functions</a><a class="docs-heading-anchor-permalink" href="#Minor-helper-functions-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:|" href="#Base.:|"><code>Base.:|</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.:|(x::PathRelinkingResult,
        y::PathRelinkingResult)::PathRelinkingResult</code></pre><p>Perform bitwise <code>OR</code> between two <a href="#BrkgaMpIpr.PathRelinkingResult"><code>PathRelinkingResult</code></a> returning the highest rank <code>PathRelinkingResult</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; TOO_HOMOGENEOUS | NO_IMPROVEMENT
NO_IMPROVEMENT::PathRelinkingResult = 1

julia&gt; NO_IMPROVEMENT | ELITE_IMPROVEMENT
ELITE_IMPROVEMENT::PathRelinkingResult = 3

julia&gt; ELITE_IMPROVEMENT | BEST_IMPROVEMENT
BEST_IMPROVEMENT::PathRelinkingResult = 7</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.empty_function" href="#BrkgaMpIpr.empty_function"><code>BrkgaMpIpr.empty_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">const empty_function() = nothing</code></pre><p>Represent an empty function to be used as flag during data and bias function setups.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.find_block_range" href="#BrkgaMpIpr.find_block_range"><code>BrkgaMpIpr.find_block_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_block_range(block_number::Int64, block_size::Int64,
                 max_end::Int64)::UnitRange{Int64}</code></pre><p>Return a positive range for the given <code>block_number</code> with length <code>block_size</code>, limited to the <code>max_end</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function only accept positive numbers, and all sanity check is disregarded due to performance reasons.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>THIS IS AN INTERNAL DATA STRUCTURE AND IT IS NOT MEANT TO BE USED DIRECTLY.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.swap!" href="#BrkgaMpIpr.swap!"><code>BrkgaMpIpr.swap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">swap!(x::Array{Any, 1}, pos1::Int64, pos2::Int64)</code></pre><p>Swap the value in position <code>pos1</code> with the value in position <code>pos2</code> in vector <code>x</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function only accept positive numbers, and all sanity and bounds check is disregarded due to performance reasons.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>THIS IS AN INTERNAL DATA STRUCTURE AND IT IS NOT MEANT TO BE USED DIRECTLY.</p></div></div></div></section></article><h3 id="Major-helper-functions-1"><a class="docs-heading-anchor" href="#Major-helper-functions-1">Major helper functions</a><a class="docs-heading-anchor-permalink" href="#Major-helper-functions-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.evolve_population!" href="#BrkgaMpIpr.evolve_population!"><code>BrkgaMpIpr.evolve_population!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evolve_population!(brkga_data::BrkgaData, population_index::Int64)</code></pre><p>Evolve the population <code>population_index</code> to the next generation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Although this method allows us to evolve populations independently, and therefore, provide nice flexibility, the generation of each population can be unsyched. We must proceed with care when using this function instead of <a href="#BrkgaMpIpr.evolve!"><code>evolve!()</code></a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The decoding is done in parallel using threads, and the user <strong>must guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be held, we suggest using single thread by setting the environmental variable <code>JULIA_NUM_THREADS = 1</code> <a href="https://docs.julialang.org/en/v1.1/manual/parallel-computing/">(see Julia Parallel Computing)</a>.</p></div></div><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: if <a href="#BrkgaMpIpr.initialize!"><code>initialize!()</code></a> was not called before.</li><li><code>ArgumentError</code>: when <code>population_index &lt; 1</code> or <code>population_index &gt; num_independent_populations</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.direct_path_relink!" href="#BrkgaMpIpr.direct_path_relink!"><code>BrkgaMpIpr.direct_path_relink!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function direct_path_relink!(brkga_data::BrkgaData,
                             chromosome1::Array{Float64, 1},
                             chromosome2::Array{Float64, 1},
                             affect_solution::Function,
                             block_size::Int64,
                             max_time::Float64,
                             percentage::Float64
    )::Tuple{Float64, Array{Float64, 1}}</code></pre><p>Perform the direct path relinking, changing each allele or block of alleles of base chromosome for the correspondent one in the guide chromosome.</p><p>The API will call <code>decode!()</code> function always with <code>writeback = false</code>. The reason is that if the decoder rewrites the chromosome, the path between solutions is lost and inadvertent results may come up. Note that at the end of the path relinking, the method calls the decoder with <code>writeback = true</code> in the best chromosome found to guarantee that this chromosome is re-written to reflect the best solution found.</p><p>This method is a multi-thread implementation. Instead of to build and decode each chromosome one at a time, the method builds a list of candidates, altering the alleles/keys according to the guide solution, and then decode all candidates in parallel. Note that <code>O(chromosome_size^2 / block_size)</code> additional memory is necessary to build the candidates, which can be costly if the <code>chromosome_size</code> is very large.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>As it is in <a href="#BrkgaMpIpr.evolve!"><code>evolve!()</code></a>, the decoding is done in parallel using threads, and the user <strong>must guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be held, we suggest using single thread by setting the environmental variable <code>JULIA_NUM_THREADS = 1</code> <a href="https://docs.julialang.org/en/v1.1/manual/parallel-computing/">(see Julia Parallel Computing)</a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>THIS IS AN INTERNAL METHOD AND IT IS NOT MEANT TO BE USED DIRECTLY. IT IS CALLED FROM THE <a href="#BrkgaMpIpr.path_relink!"><code>path_relink!()</code></a> FUNCTION. Due to this reason, this method <strong>DOES NOT</strong> perform health checks on the arguments.</p></div></div><p><strong>Arguments</strong></p><ul><li><p><a href="#BrkgaMpIpr.BrkgaData"><code>brkga_data::BrkgaData</code></a>: the BRKGA data.</p></li><li><p><code>chromosome1::Array{Float64, 1}</code> and <code>chromosome2::Array{Float64, 1}</code>: the chromosomes to be used to build the path.</p></li><li><p><code>affect_solution::Function</code>: function that takes two partial chromosomes / block of genes <code>block1</code> and <code>block2</code> and checks whether changing the keys from <code>block1</code> to <code>block2</code> affects the solution. For instance, suppose that the alleles/keys are used as threshold such that values &gt; 0.5 activate a feature. Suppose we have <code>block1 = [0.3, 0.4, 0.1]</code> and <code>block2 = [0.4, 0.1, 0.2]</code>. Since all values are below 0.5, changing the keys from <code>block1</code> to <code>block2</code> does not chage the solution, and therefore, we can drop such change (and subsequentely decoding). The blocks can hold only one key/allele, sequential key blocks, of even the whole chromosome. <code>affect_solution</code> takes two views/subarrays. The function <strong>MUST HAVE</strong> the following signature</p><pre><code class="language-julia">affect_solution(block1::SubArray{Float64, 1},
                block2::SubArray{Float64, 1})::Bool</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function depends on the problem structure and how the   keys/alleles are used.</p></div></div></li><li><p><code>block_size::Int64</code>: (posite) number of alleles to be exchanged at once in each iteration. If <code>block_size == 1</code>, the traditional path relinking is performed.</p></li><li><p><code>max_time::Float64</code>: abort path-relinking when reach <code>max_time</code>. If <code>max_time &lt;= 0</code>, no limit is imposed. Given in seconds.</p></li><li><p><code>percentage::Float64</code>: define the size, in percentage, of the path to build. Range [0, 1].</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Any, 1}</code>: the best pair [fitness, chromosome] found during the relinking. If the relink is not possible due to homogeneity, <code>-Inf</code> returns in case of maximization, and <code>Inf</code> in case of minimization.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BrkgaMpIpr.permutation_based_path_relink!" href="#BrkgaMpIpr.permutation_based_path_relink!"><code>BrkgaMpIpr.permutation_based_path_relink!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function permutation_based_path_relink!(brkga_data::BrkgaData,
                                        chromosome1::Array{Float64, 1},
                                        chromosome2::Array{Float64, 1},
                                        affect_solution::Function,
                                        block_size::Int64,
                                        max_time::Float64,
                                        percentage::Float64
    )::Tuple{Float64, Array{Float64, 1}}</code></pre><p>Perform the permutation-based path relinking. In this method, the permutation induced by the keys in the guide solution is used to change the order of the keys in the permutation induced by the base solution.</p><p>The API will call <code>decode!()</code> function always with <code>writeback = false</code>. The reason is that if the decoder rewrites the chromosome, the path between solutions is lost and inadvertent results may come up. Note that at the end of the path relinking, the method calls the decoder with <code>writeback = true</code> in the best chromosome found to guarantee that this chromosome is re-written to reflect the best solution found.</p><p>This method is a multi-thread implementation. Instead of to build and decode each chromosome one at a time, the method builds a list of candidates, altering the alleles/keys according to the guide solution, and then decode all candidates in parallel. Note that <code>O(chromosome_size^2 / block_size)</code> additional memory is necessary to build the candidates, which can be costly if the <code>chromosome_size</code> is very large.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>As it is in <a href="#BrkgaMpIpr.evolve!"><code>evolve!()</code></a>, the decoding is done in parallel using threads, and the user <strong>must guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be held, we suggest using single thread by setting the environmental variable <code>JULIA_NUM_THREADS = 1</code> <a href="https://docs.julialang.org/en/v1.1/manual/parallel-computing/">(see Julia Parallel Computing)</a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>THIS IS AN INTERNAL METHOD AND IT IS NOT MEANT TO BE USED DIRECTLY. IT IS CALLED FROM THE <a href="#BrkgaMpIpr.path_relink!"><code>path_relink!()</code></a> FUNCTION. Due to this reason, this method <strong>DOES NOT</strong> perform health checks on the arguments.</p></div></div><p><strong>Arguments</strong></p><ul><li><p><a href="#BrkgaMpIpr.BrkgaData"><code>brkga_data::BrkgaData</code></a>: the BRKGA data.</p></li><li><p><code>chromosome1::Array{Float64, 1}</code> and <code>chromosome2::Array{Float64, 1}</code>: the chromosomes to be used to build the path.</p></li><li><p><code>affect_solution::Function</code>: not used in this function but kept to API compatibility.</p></li><li><p><code>block_size::Int64</code>: not used in this function but kept to API compatibility.</p></li><li><p><code>max_time::Float64</code>: abort path-relinking when reach <code>max_time</code>. If <code>max_time &lt;= 0</code>, no limit is imposed. Given in seconds.</p></li><li><p><code>percentage::Float64</code>: define the size, in percentage, of the path to      build. Range [0, 1].</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Any, 1}</code>: the best pair [fitness, chromosome] found during the relinking. If the relink is not possible due to homogeneity, <code>-Inf</code> returns in case of maximization, and <code>Inf</code> in case of minimization.</li></ul></div></section></article><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#BrkgaMpIpr.AbstractInstance"><code>BrkgaMpIpr.AbstractInstance</code></a></li><li><a href="#BrkgaMpIpr.BiasFunction"><code>BrkgaMpIpr.BiasFunction</code></a></li><li><a href="#BrkgaMpIpr.BrkgaData"><code>BrkgaMpIpr.BrkgaData</code></a></li><li><a href="#BrkgaMpIpr.BrkgaParams"><code>BrkgaMpIpr.BrkgaParams</code></a></li><li><a href="#BrkgaMpIpr.DecodeStruct"><code>BrkgaMpIpr.DecodeStruct</code></a></li><li><a href="#BrkgaMpIpr.ExternalControlParams"><code>BrkgaMpIpr.ExternalControlParams</code></a></li><li><a href="#BrkgaMpIpr.PathRelinkingResult"><code>BrkgaMpIpr.PathRelinkingResult</code></a></li><li><a href="#BrkgaMpIpr.PathRelinkingSelection"><code>BrkgaMpIpr.PathRelinkingSelection</code></a></li><li><a href="#BrkgaMpIpr.PathRelinkingType"><code>BrkgaMpIpr.PathRelinkingType</code></a></li><li><a href="#BrkgaMpIpr.Population"><code>BrkgaMpIpr.Population</code></a></li><li><a href="#BrkgaMpIpr.Sense"><code>BrkgaMpIpr.Sense</code></a></li><li><a href="#BrkgaMpIpr.ShakingType"><code>BrkgaMpIpr.ShakingType</code></a></li><li><a href="#BrkgaMpIpr.Triple"><code>BrkgaMpIpr.Triple</code></a></li><li><a href="#Base.:|"><code>Base.:|</code></a></li><li><a href="#Base.parse"><code>Base.parse</code></a></li><li><a href="#BrkgaMpIpr.affect_solution_hamming_distance"><code>BrkgaMpIpr.affect_solution_hamming_distance</code></a></li><li><a href="#BrkgaMpIpr.affect_solution_kendall_tau"><code>BrkgaMpIpr.affect_solution_kendall_tau</code></a></li><li><a href="#BrkgaMpIpr.build_brkga"><code>BrkgaMpIpr.build_brkga</code></a></li><li><a href="#BrkgaMpIpr.direct_path_relink!"><code>BrkgaMpIpr.direct_path_relink!</code></a></li><li><a href="#BrkgaMpIpr.empty_function"><code>BrkgaMpIpr.empty_function</code></a></li><li><a href="#BrkgaMpIpr.evolve!"><code>BrkgaMpIpr.evolve!</code></a></li><li><a href="#BrkgaMpIpr.evolve_population!"><code>BrkgaMpIpr.evolve_population!</code></a></li><li><a href="#BrkgaMpIpr.exchange_elite!"><code>BrkgaMpIpr.exchange_elite!</code></a></li><li><a href="#BrkgaMpIpr.find_block_range"><code>BrkgaMpIpr.find_block_range</code></a></li><li><a href="#BrkgaMpIpr.get_best_chromosome"><code>BrkgaMpIpr.get_best_chromosome</code></a></li><li><a href="#BrkgaMpIpr.get_best_fitness"><code>BrkgaMpIpr.get_best_fitness</code></a></li><li><a href="#BrkgaMpIpr.get_chromosome"><code>BrkgaMpIpr.get_chromosome</code></a></li><li><a href="#BrkgaMpIpr.get_current_population"><code>BrkgaMpIpr.get_current_population</code></a></li><li><a href="#BrkgaMpIpr.hamming_distance"><code>BrkgaMpIpr.hamming_distance</code></a></li><li><a href="#BrkgaMpIpr.initialize!"><code>BrkgaMpIpr.initialize!</code></a></li><li><a href="#BrkgaMpIpr.inject_chromosome!"><code>BrkgaMpIpr.inject_chromosome!</code></a></li><li><a href="#BrkgaMpIpr.kendall_tau_distance"><code>BrkgaMpIpr.kendall_tau_distance</code></a></li><li><a href="#BrkgaMpIpr.load_configuration"><code>BrkgaMpIpr.load_configuration</code></a></li><li><a href="#BrkgaMpIpr.path_relink!"><code>BrkgaMpIpr.path_relink!</code></a></li><li><a href="#BrkgaMpIpr.permutation_based_path_relink!"><code>BrkgaMpIpr.permutation_based_path_relink!</code></a></li><li><a href="#BrkgaMpIpr.reset!"><code>BrkgaMpIpr.reset!</code></a></li><li><a href="#BrkgaMpIpr.set_bias_custom_function!"><code>BrkgaMpIpr.set_bias_custom_function!</code></a></li><li><a href="#BrkgaMpIpr.set_initial_population!"><code>BrkgaMpIpr.set_initial_population!</code></a></li><li><a href="#BrkgaMpIpr.shake!"><code>BrkgaMpIpr.shake!</code></a></li><li><a href="#BrkgaMpIpr.swap!"><code>BrkgaMpIpr.swap!</code></a></li><li><a href="#BrkgaMpIpr.write_configuration"><code>BrkgaMpIpr.write_configuration</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../license/">« License</a><a class="docs-footer-nextpage" href="../contributing/">Contributing »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 3 April 2020 19:22">Friday 3 April 2020</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
