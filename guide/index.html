<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide / Tutorial · BrkgaMpIpr.jl documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="BrkgaMpIpr.jl documentation logo"/></a><h1>BrkgaMpIpr.jl documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Guide / Tutorial</a><ul class="internal"><li><a class="toctext" href="#Installation-and-tests-1">Installation and tests</a></li><li><a class="toctext" href="#TL;DR-1">TL;DR</a></li><li><a class="toctext" href="#Getting-started-1">Getting started</a></li><li><a class="toctext" href="#First-things-first:-basic-data-structures-and-decoder-function-1">First things first: basic data structures and decoder function</a></li><li><a class="toctext" href="#Building-BRKGA-MP-IPR-data-structures-1">Building BRKGA-MP-IPR data structures</a></li><li><a class="toctext" href="#Initialization-and-Warm-start-solutions-1">Initialization and Warm-start solutions</a></li><li><a class="toctext" href="#Optimization-time:-evolving-the-population-1">Optimization time: evolving the population</a></li><li><a class="toctext" href="#Accessing-solutions/chromosomes-1">Accessing solutions/chromosomes</a></li><li><a class="toctext" href="#Implicit-Path-Relink-1">Implicit Path Relink</a></li><li><a class="toctext" href="#Shaking-and-Resetting-1">Shaking and Resetting</a></li><li><a class="toctext" href="#Multi-population-and-migration-1">Multi-population and migration</a></li><li><a class="toctext" href="#Simulating-the-standard-BRKGA-1">Simulating the standard BRKGA</a></li><li><a class="toctext" href="#Reading-and-writing-parameters-1">Reading and writing parameters</a></li><li><a class="toctext" href="#(Probable-Valuable)-Tips-1">(Probable Valuable) Tips</a></li></ul></li><li><a class="toctext" href="../license/">License</a></li><li><a class="toctext" href="../api/">Library</a></li><li><a class="toctext" href="../contributing/">Contributing</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Guide / Tutorial</a></li></ul><a class="edit-page" href="https://github.com/ceandrade/BrkgaMpIpr.jl/blob/master/docs/src/guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Guide / Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Guide-/-Tutorial-1" href="#Guide-/-Tutorial-1">Guide / Tutorial</a></h1><h2><a class="nav-anchor" id="Installation-and-tests-1" href="#Installation-and-tests-1">Installation and tests</a></h2><p>BrkgaMpIpr can be installed using the Julia package manager. From the Julia REPL, type <code>]</code> to enter the Pkg REPL mode and run</p><pre><code class="language-julia-repl">pkg&gt; add BrkgaMpIpr</code></pre><p>BrkgaMpIpr also provides a thorough unit testing that aims to harden and make the code ready for production environments. From Pkg REPL, just run</p><pre><code class="language-julia-repl">pkg&gt; test</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The tests take about 10 minutes, mainly because the permutation path relink.</p></div></div><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>It is a hard test to test algorithms that use random signals. In BrkgaMpIpr, the tests are carefully designed to ensure repeatability. For that, we use the Mersenne Twister <a href="https://en.wikipedia.org/wiki/Mersenne_Twister">[1]</a> <a href="http://dx.doi.org/10.1145/272991.272995">[2]</a> as our standard random generator number engine, particularly the <a href="https://docs.julialang.org/en/v1/stdlib/Random/index.html#Random.MersenneTwister">version that comes with Julia</a>. However, it may happen that such engine has slightly different implementations across platforms and, therefore, the tests may fail. The current version was tested on 64-bit platforms (Mac OS X, GNU/Linux, and Windows 10).</p></div></div><h2><a class="nav-anchor" id="TL;DR-1" href="#TL;DR-1">TL;DR</a></h2><p>The best way to keep it short is to look in the <a href="https://github.com/ceandrade/BrkgaMpIpr/tree/v1.0/examples"><code>examples</code></a> folder on <a href="https://github.com/ceandrade/BrkgaMpIpr">the git repo.</a> From <a href="https://github.com/ceandrade/test_ze/blob/v1.0/examples/tsp/main_minimal.jl"><code>main_minimal.jl</code></a>, you can identify the following basic steps:</p><ol><li><p>Create a data structure inherited from <a href="../api/#BrkgaMpIpr.AbstractInstance"><code>AbstractInstance</code></a> to hold your input data. This object is passed to the decoder function (example <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/tsp_instance.jl"><code>tsp_instance.jl</code></a>);</p></li><li><p>Implement a decoder function. This function translates a chromosome (array of numbers in the interval [0,1]) to a solution for your problem. The decoder must return the solution value or cost to be used as fitness by BRKGA (example <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/tsp_decoder.jl"><code>tsp_decoder.jl</code></a>);</p></li><li><p>Load the instance and other relevant data;</p></li><li><p>Use <a href="../api/#BrkgaMpIpr.build_brkga"><code>build_brkga</code></a> to create a <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> that represents the internal state of the BRKGA-MP-IPR algorithm;</p></li><li><p>Use <a href="../api/#BrkgaMpIpr.initialize!"><code>initialize!</code></a> to init the BRKGA state;</p></li><li><p>Call <a href="../api/#BrkgaMpIpr.evolve!"><code>evolve!</code></a> to optimize;</p></li><li><p>Call <a href="../api/#BrkgaMpIpr.get_best_fitness"><code>get_best_fitness</code></a> and/or <a href="../api/#BrkgaMpIpr.get_best_chromosome"><code>get_best_chromosome</code></a> to retrieve the best solution.</p></li></ol><p>These are the basic steps, but I do recommend the reading of this guide.</p><h2><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h2><p>BrkgaMpIpr is pretty simple, and you must provide one required data structure representing the <em>problem instance</em>, and one required <em>decoder</em> function to translate chromosomes to solutions.</p><p>Before you go further, please take a look at the <a href="https://github.com/ceandrade/BrkgaMpIpr/tree/v1.0/examples"><code>examples</code></a> folder in <a href="https://github.com/ceandrade/BrkgaMpIpr">the git repo</a>. We will use parts of that code in this guide. There, we solve the classical <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Traveling Salesman Problem</a>. Given a set of cities and the distances between them (full weighted undirect graph), one must find a minimum-cost tour among all cities, such that each city is visited only once (i.e., find a Hamiltonian cycle of minimum cost). These are the files:</p><ul><li><p><a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/tsp_instance.jl"><code>tsp_instance.jl</code></a>: contains the input data structures and helper functions;</p></li><li><p><a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/tsp_decoder.jl"><code>tsp_decoder.jl</code></a>: contains the decoder function for TSP;</p></li><li><p><a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/greedy_tour.jl"><code>greedy_tour.jl</code></a>: simple heuristic that computes a greedy tour;</p></li><li><p><a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/config.conf"><code>config.conf</code></a>:</p></li><li><p><code>config.conf</code>: example of parameter settings;</p></li><li><p><a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_minimal.jl"><code>main_minimal.jl</code></a>: minimal code useful to understand and test the framework. <strong>You should start here!</strong> Please take a look on this file before continue this tutorial;</p></li><li><p><a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_complete.jl"><code>main_complete.jl</code></a>: full-featured code, handy for scientific use, such as experimentation and paper writing. This code allows fine-grained control of the optimization, show several features of BRKGA-MP-IPR such as the path-reliking calls, resets, chromosome injection, and others. It also logs all optimization steps, creating outputs easy to be parsed. <strong>You should use this code for serious business and experimentation;</strong></p></li><li><p><a href="https://github.com/ceandrade/BrkgaMpIpr//tree/v1.0/examples/tsp/instances"><code>instances</code></a>: folder containing some TSP instances for testing.</p></li></ul><p>When you call <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_minimal.jl"><code>main_minimal.jl</code></a> or <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_complete.jl"><code>main_complete.jl</code></a> without arguments, they show the usage. For example, assuming you are using a terminal:</p><pre><code class="language-bash">$ julia main_minimal.jl
Usage: julia main_minimal.jl &lt;seed&gt; &lt;config-file&gt; &lt;num-generations&gt; &lt;tsp-instance-file&gt;

$ julia main_complete.jl
Usage:
  main_complete.jl -c &lt;config_file&gt; -s &lt;seed&gt; -r &lt;stop_rule&gt; -a &lt;stop_arg&gt; -t &lt;max_time&gt; -i &lt;instance_file&gt; [--no_evolution]
  main_complete.jl (-h | --help)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_complete.jl"><code>main_complete.jl</code></a> uses the <a href="https://github.com/docopt/DocOpt.jl">DocOpt package</a>. Please, install it before run this script.</p></div></div><p>So, this is a possible output whe calling <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_minimal.jl"><code>main_minimal.jl</code></a>:</p><pre><code class="language-bash">$ julia main_minimal.jl 27000001 config.conf 100 instances/brazil58.dat
Reading data...
Building BRKGA data and initializing...
Evolving 100 generations...
best_cost = 37552.0</code></pre><p>For <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_complete.jl"><code>main_complete.jl</code></a>, the output is more verbose, since we want to capture as much information as possible to do some statistical analysis. The output should be something close to this:</p><pre><code class="language-bash">$ julia main_complete.jl -c config.conf -s 2700001 -r Generations -a 100 -t 60 -i instances/brazil58.dat
------------------------------------------------------
&gt; Experiment started at 2019-02-13T18:40:11.789
&gt; Instance: instances/brazil58.dat
&gt; Configuration: config.conf
&gt; Algorithm Parameters:
&gt;  - population_size 2000
&gt;  - elite_percentage 0.3
&gt;  - mutants_percentage 0.15
&gt;  - num_elite_parents 2
&gt;  - total_parents 3
&gt;  - bias_type LOGINVERSE
&gt;  - num_independent_populations 3
&gt;  - pr_number_pairs 0
&gt;  - pr_minimum_distance 0.15
&gt;  - pr_type PERMUTATION
&gt;  - pr_selection BESTSOLUTION
&gt;  - alpha_block_size 1.0
&gt;  - pr_percentage 1.0
&gt;  - exchange_interval 200
&gt;  - num_exchange_indivuduals 2
&gt;  - reset_interval 600
&gt; Seed: 2700001
&gt; Stop rule: GENERATIONS
&gt; Stop argument: 100
&gt; Maximum time (s): 60.0
&gt; Number of parallel threads for decoding: 1
------------------------------------------------------

[18:40:11.87] Reading TSP data...
Number of nodes: 58

[18:40:11.906] Generating initial tour...
Initial cost: 30774.0

[18:40:11.909] Building BRKGA data...
New population size: 580

[18:40:12.092] Initializing BRKGA data...

[18:40:12.247] Warming up...

[18:40:12.771] Evolving...
* Iteration | Cost | CurrentTime
* 1 | 30774 | 0.03
* 34 | 30751 | 0.83
* 35 | 30507 | 0.85
* 36 | 30088 | 0.87
* 38 | 30023 | 0.93
* 39 | 29882 | 0.95
* 40 | 29665 | 0.97
* 41 | 29131 | 1.00
* 57 | 28221 | 1.38
* 66 | 28211 | 1.59
* 83 | 28200 | 2.01
* 86 | 28129 | 2.08
* 91 | 28118 | 2.19
[18:40:15.171] End of optimization

Total number of iterations: 100
Last update iteration: 91
Total optimization time: 2.40
Last update time: 2.19
Large number of iterations between improvements: 33
Total path relink time: 0.00
Total path relink calls: 0
Number of homogenities: 0
Improvements in the elite set: 0
Best individual improvements: 0

% Best tour cost: 28118
% Best tour: 22 8 1 30 13 40 25 9 32 20 53 50 4 18 44 24 58 5 27 43 12 57 23 54 55 2 41 35 10 52 51 47 49 3 48 39 29 36 17 26 19 6 28 14 37 34 56 46 15 45 33 21 11 16 42 38 31 7

Instance,Seed,NumNodes,TotalIterations,TotalTime,TotalPRTime,PRCalls,NumHomogenities,NumPRImprovElite,NumPrImprovBest,LargeOffset,LastUpdateIteration,LastUpdateTime,Cost
brazil58.dat,2700001,58,100,2.40,0.00,0,0,0,0,33,91,2.19,28118</code></pre><p>I hope by now you got your system set up and running. Let&#39;s see the essential details on how to use the BrkgaMpIpr.</p><h2><a class="nav-anchor" id="First-things-first:-basic-data-structures-and-decoder-function-1" href="#First-things-first:-basic-data-structures-and-decoder-function-1">First things first: basic data structures and decoder function</a></h2><p>All problem information must be encapsulated in a struct inherited from <a href="../api/#BrkgaMpIpr.AbstractInstance"><code>AbstractInstance</code></a>. <a href="../api/#BrkgaMpIpr.AbstractInstance"><code>AbstractInstance</code></a> is an empty-abstract struct required in the signature of the <em>decoder</em> function (described further). For example, assume we want to solve the Traveling Salesman Problem. One possible instance struct could be:</p><pre><code class="language-julia">struct TSP_Instance &lt;: AbstractInstance
    num_nodes::Int64
    distances::Array{Float64}
end</code></pre><p>So, note that we have the number of nodes/cities<code>num_nodes</code>, and the distance matrix <code>distances</code>. We may need some additional code to load the instance and to deal with the distance matrix (omitted here, see <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/tsp_instance.jl"><code>tsp_instance.jl</code></a>).</p><p>The second and most important requirement is the <strong>decoder function</strong>. The mandatory signature of the decoder is</p><pre><code class="language-julia">decode!(chromosome::Array{Float64, 1},
        problem_instance::AbstractInstance,
        rewrite::Bool = true)::Float64</code></pre><p><code>chromosome</code> is a vector of numbers in the interval [0, 1] to be decoded. <code>problem_instance</code> is the data structure containing information about the problem. Such data is used by the decoder to build a solution. <code>rewrite</code> is an optional argument that indicates if the decoder should rewrite the chromosome, in case of local search / local improvements be performed during the decoder process. This flag is critical if you intend to use the Implicit Path Relink (details on <a href="../api/#BrkgaMpIpr.path_relink!"><code>path_relink!</code></a>). The decoder must return a <code>Float64</code> that is used as the <strong>fitness</strong> to rank the chromosomes. In general, fitness is the cost/value of the solution, but you may want to use it to penalize solutions that violate the problem constraints, for example.</p><p>In our TSP example, we have a very simple decoder that generates a permutation of nodes, and compute the cost of the cycle from that permutation (note the used of function <code>distance</code> that returns the distance between two nodes and it is defined on <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/tsp_instance.jl"><code>tsp_instance.jl</code></a>).</p><pre><code class="language-julia">function tsp_decode!(chromosome::Array{Float64}, instance::TSP_Instance,
                     rewrite::Bool = true)::Float64

    permutation = Array{Tuple{Float64, Int64}}(undef, instance.num_nodes)
    for (index, key) in enumerate(chromosome)
        permutation[index] = (key, index)
    end

    sort!(permutation)

    cost = distance(instance, permutation[1][2], permutation[end][2])
    for i in 1:(instance.num_nodes - 1)
        cost += distance(instance, permutation[i][2], permutation[i + 1][2])
    end

    return cost
end</code></pre><p>With the instance data and the decoder ready, we can build the BRKGA data structures and perform the optimization.</p><h2><a class="nav-anchor" id="Building-BRKGA-MP-IPR-data-structures-1" href="#Building-BRKGA-MP-IPR-data-structures-1">Building BRKGA-MP-IPR data structures</a></h2><p>BrkgaMpIpr framework revolves over a single data structure called <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> that represents the internal state of the BRKGA-MP-IPR algorithm. Since this structure has no constructor, you must build it using one of the <a href="../api/#building_funcs-1"><code>Building functions</code></a>. There are two <a href="../api/#BrkgaMpIpr.build_brkga"><code>build_brkga</code></a> methods:</p><ul><li>load the parameters from a file:</li></ul><pre><code class="language-julia">function build_brkga(
    problem_instance::AbstractInstance,
    decode_function!::Function,
    opt_sense::Sense,
    seed::Int64,
    chromosome_size::Int64,
    configuration_file::String,
    evolutionary_mechanism_on::Bool = true
)::Tuple{BrkgaData, ExternalControlParams}</code></pre><ul><li>load the parameters from a hand-made parameter object:</li></ul><pre><code class="language-julia">function build_brkga(
    problem_instance::AbstractInstance,
    decode_function!::Function,
    opt_sense::Sense,
    seed::Int64,
    chromosome_size::Int64,
    brkga_params::BrkgaParams,
    evolutionary_mechanism_on::Bool = true,
)::BrkgaData</code></pre><p>Both methods require a <code>problem_instance</code> to be used in the <code>decode_function!</code> as commented before.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>To date, there is not an easy and clean way to force a function type, as we can do in C and C++, and then, <code>decode_function!</code> is declared as a simple, high-level <code>Function</code> type. However, <code>decode_function!</code> must have the expected signature as explained before.</p></div></div><p>You also must indicate whether you are minimizing or maximizing through optimization <a href="../api/#BrkgaMpIpr.Sense"><code>Sense</code></a>.</p><p>A good seed also must be provided for the (pseudo) random number generator (according to <a href="http://doi.acm.org/10.1145/1276927.1276928">this paper</a>). BrkgaMpIpr uses the Mersenne Twister <a href="http://dx.doi.org/10.1145/272991.272995">[1]</a> <a href="https://en.wikipedia.org/wiki/Mersenne_Twister">[2]</a>.</p><p>The <code>chromosome_size</code> also must be given. It indicates the length of each chromosome in the population. In general, this size depends on the instance and how the decoder works.</p><p>Another common argument is <code>evolutionary_mechanism_on</code> which is enabled by default. When disabled, no evolution is performed. The algorithm only decodes the chromosomes and ranks them. On each generation, all population is replaced excluding the best chromosome. This flag helps on implementations of simple multi-start algorithms.</p><p>As said before, the difference between the two methods is from where the algorithm&#39;s hyper-parameters come from. In the first version, the algorithm reads the BRKGA, IPR, and extra parameters from a simple text file that looks like this (see <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/config.conf"><code>config.conf</code></a> for detailed example):</p><pre><code class="language-txt">population_size 2000
elite_percentage 0.30
mutants_percentage 0.15
num_elite_parents 2
total_parents 3
bias_type LOGINVERSE
num_independent_populations 3
pr_number_pairs 0
pr_minimum_distance 0.15
pr_type PERMUTATION
pr_selection BESTSOLUTION
alpha_block_size 1.0
pr_percentage 1.0
exchange_interval 200
num_exchange_indivuduals 2
reset_interval 600</code></pre><p>When reading such file, the algorithm ignores all blank lines, and lines starting with <strong>#</strong>. During the building process, the building method creates a <a href="../api/#BrkgaMpIpr.BrkgaParams"><code>BrkgaParams</code></a> object and a <a href="../api/#BrkgaMpIpr.ExternalControlParams"><code>ExternalControlParams</code></a> object. <a href="../api/#BrkgaMpIpr.BrkgaParams"><code>BrkgaParams</code></a> contains all hyper-parameters regarding BRKGA and IPR methods and is stored in the brand-new <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> returned by the method. <a href="../api/#BrkgaMpIpr.ExternalControlParams"><code>ExternalControlParams</code></a> are parameters that can be used outside the BRKGA-MP-IPR to control several aspects of the optimization. For instance, interval to apply path relink, reset the population, perform population migration, among others. Although their presence is required on the config file, they are not mandatory to the BRKGA-MP-IPR itself.</p><p>In the second method, we assume we already have a <a href="../api/#BrkgaMpIpr.BrkgaParams"><code>BrkgaParams</code></a> object, and we just pass it directly to the function. Note that such param data is deep-copied inside <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a>.</p><p>Let&#39;s take a look in the example from <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_minimal.jl"><code>main_minimal.jl</code></a>:</p><pre><code class="language-julia">seed = parse(Int64, ARGS[1])
configuration_file = ARGS[2]
num_generations = parse(Int64, ARGS[3])
instance_file = ARGS[4]

instance = TSP_Instance(instance_file)

brkga_data, control_params = build_brkga(
    instance, tsp_decode!, MINIMIZE, seed, instance.num_nodes,
    configuration_file
)</code></pre><p>This code gets some arguments from the command line and loads a TSP instance. After that, it builds <code>brkga_data</code>. Note that we pass the <code>instance</code> data and the <code>tsp_decode!</code> function. Since we are looking for cycles of minimum cost, we ask for the algorithm <code>MINIMIZE</code>. The starting seed is also given. Since <code>tsp_decode!</code> considers each chromosome key as a node/city, the length of the chromosome must be the number of nodes, i.e., <code>instance.num_nodes</code>. Finally, we also pass the configuration file.</p><p>Let&#39;s take a look in a more elaborated example (<a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_complete.jl"><code>main_complete.jl</code></a>):</p><pre><code class="language-julia">brkga_params, control_params = load_configuration(configuration_file)
...
brkga_params.population_size = min(brkga_params.population_size,
                                   10 * instance.num_nodes)
...
brkga_data = build_brkga(instance, tsp_decode!, MINIMIZE, seed,
                         instance.num_nodes, brkga_params, perform_evolution)</code></pre><p>Here, we first load the configuration file using the helper function <a href="../api/#BrkgaMpIpr.load_configuration"><code>load_configuration</code></a>. Then, we modify the population size to be the minimum between the original parameter and 10x the number of nodes (<em>making the population size proportional to the instance size is a very common strategy used in genetic algorithms</em>). Then, we call <a href="../api/#BrkgaMpIpr.build_brkga"><code>build_brkga</code></a> using the param data instead of the configuration file (there is an additional parameter <code>perform_evolution</code> to tune the evolution either on or off, not necessary at this moment).</p><p>Now, we have a <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> which will be used in all other functions during the optimization. Note that we can build several <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> objects using different parameters, decoders, or instance data. These structures can be evolved in parallel and mixed-and-matched at your will. Each one holds a self-contained BRKGA state including populations, fitness information, and a state of the random number generator.</p><h2><a class="nav-anchor" id="Initialization-and-Warm-start-solutions-1" href="#Initialization-and-Warm-start-solutions-1">Initialization and Warm-start solutions</a></h2><p>Before starting the optimization, we need to initialize <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> using <a href="../api/#BrkgaMpIpr.initialize!"><code>initialize!</code></a> function. This procedure initializes the populations and others data structures of the BRKGA. If an initial population (warm start) is supplied, the initialization method completes the remaining individuals, if they do not exist. This method also performs the initial decoding of the chromosomes. Therefore, depending on the decoder implementation, this can take a while, and you may want to time such procedure. The syntax is pretty straightforward:</p><pre><code class="language-julia">initialize!(brkga_data)</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>initialize!</code> must be called before any optimization methods.</p></div></div><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>BrkgaMpIpr performs the decoding of each chromosome in parallel if multi-thread is enabled. Therefore, <strong>we must guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be held, we suggest using a single thread by setting the environmental variable <code>JULIA_NUM_THREADS = 1</code> <a href="https://docs.julialang.org/en/v1/manual/parallel-computing">(see Julia Parallel Computing)</a>.</p></div></div><h3><a class="nav-anchor" id="Warm-start-solutions-1" href="#Warm-start-solutions-1">Warm-start solutions</a></h3><p>One good strategy is to bootstrap the main optimization algorithm with good solutions from fast heuristics [<a href="http://dx.doi.org/10.1002/net.21685">1</a>, <a href="http://dx.doi.org/10.1016/j.ejor.2017.10.045">2</a>, <a href="http://dx.doi.org/10.1016/j.ejor.2017.10.045">3</a>] or even from relaxations of integer linear programming models <a href="http://dx.doi.org/10.1162/EVCO_a_00138">[4]</a>.</p><p>To do it, you must set these initial solutions before call <a href="../api/#BrkgaMpIpr.initialize!"><code>initialize!</code></a>. Since BRKGA-MP-IPR does not know the problem structure, you must <em>encode</em> the warm-start solution as chromosomes (vectors in the interval [0, 1]). In other words, you must do the inverse process that <code>decode!</code> does. For instance, this is a piece of code from <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_complete.jl"><code>main_complete.jl</code></a> showing this process:</p><pre><code class="language-julia">initial_cost, initial_tour = greedy_tour(instance)
...
keys = sort(rand(instance.num_nodes))
initial_chromosome = zeros(instance.num_nodes)
for i in 1:instance.num_nodes
    initial_chromosome[initial_tour[i]] = keys[i]
end
...
set_initial_population!(brkga_data, [initial_chromosome])
initialize!(brkga_data)</code></pre><p>Here, we create one incumbent solution using the greedy heuristic <code>greedy_tour()</code> found in <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/greedy_tour.jl"><code>greedy_tour.jl</code></a>. It gives us <code>initial_tour</code> which is a sequence of nodes to be visited. In the next four lines, we encode <code>initial_tour</code>. First, we create a vector of sorted random <code>keys</code>. Note that this is the same order that <code>tsp_decode!</code> uses. We then create the <code>initial_chromosome</code>, and fill it up with <code>keys</code> according to the nodes&#39; order in <code>initial_tour</code>. Finally, we use <a href="../api/#BrkgaMpIpr.set_initial_population!"><code>set_initial_population!</code></a> to assign the incumbent to the initial population. Note that <code>initial_chromosome</code> in between braces because <a href="../api/#BrkgaMpIpr.set_initial_population!"><code>set_initial_population!</code></a> takes a vector of chromosomes. See its signature:</p><pre><code class="language-julia">set_initial_population!(brkga_data::BrkgaData,
                        chromosomes::Array{Array{Float64, 1}, 1})</code></pre><p>Indeed, you can have as much warm-start solutions as you like, limited to the size of the population. Just remember:</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>set_initial_population!</code> must be called <strong>BEFORE</strong> <code>initialize!</code>.</p></div></div><h2><a class="nav-anchor" id="Optimization-time:-evolving-the-population-1" href="#Optimization-time:-evolving-the-population-1">Optimization time: evolving the population</a></h2><p>Once all data is set up, it is time to evolve the population and perform other operations like path-relinking, shaking, migration, and others. The call is pretty simple:</p><pre><code class="language-julia">evolve!(brkga_data::BrkgaData, num_generations::Int64 = 1)</code></pre><p><a href="../api/#BrkgaMpIpr.evolve!"><code>evolve!</code></a> evolves all populations for <code>num_generations</code>.</p><p>For example, in <code>main_minimal.jl</code>, we just evolve the population for a given number of generations directly and then extract the best solution cost.</p><pre><code class="language-julia">evolve!(brkga_data, num_generations)
best_cost = get_best_fitness(brkga_data)</code></pre><p>On <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_complete.jl"><code>main_complete.jl</code></a>, we have fine-grained control on the optimization. There, we have a main loop that evolves the population one generation at a time and performs several operations as to hold the best solution, to check whether it is time for path relink, population reset, among others. The advantage of that code is that we can track all optimization details.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Again, the decoding of each chromosome is done in parallel if multi-thread is enabled. Therefore, <strong>we must guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be held, we suggest using a single thread by setting the environmental variable <code>JULIA_NUM_THREADS = 1</code> <a href="https://docs.julialang.org/en/v1/manual/parallel-computing">(see Julia Parallel Computing)</a>.</p></div></div><h2><a class="nav-anchor" id="Accessing-solutions/chromosomes-1" href="#Accessing-solutions/chromosomes-1">Accessing solutions/chromosomes</a></h2><p>Since Julia does not offer encapsulation mechanisms to keep data private within data structures, you can access all chromosomes, fitness, and other data members directly from <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a>. <strong>However, we do not recommend that, unless you are sure what you are doing.</strong> So, BrkgaMpIpr offers some helper functions.</p><p>Usually, we want to access the best chromosome after some iterations. You can use the companion functions:</p><pre><code class="language-julia">get_best_fitness(brkga_data::BrkgaData)::Float64</code></pre><pre><code class="language-julia">get_best_chromosome(brkga_data::BrkgaData)::Array{Float64, 1}</code></pre><p><a href="../api/#BrkgaMpIpr.get_best_fitness"><code>get_best_fitness</code></a> returns the value/fitness of the best chromosome across all populations.</p><p><a href="../api/#BrkgaMpIpr.get_best_chromosome"><code>get_best_chromosome</code></a> returns a <em>copy</em> of the best chromosome across all populations. You may want to extract an actual solution from such chromosome, i.e., to apply a decoding function that returns the actual solution instead only its value.</p><p>You may also want to get a copy of specific chromosome for a given population using <a href="../api/#BrkgaMpIpr.get_chromosome"><code>get_chromosome</code></a>.</p><pre><code class="language-julia">get_chromosome(brkga_data::BrkgaData,
               population_index::Int64,
               position::Int64)::Array{Float64, 1}</code></pre><p>For example, you can get the 3rd best chromosome from the 2nd population using</p><pre><code class="language-julia">third_best = get_chromosome(brkga_data, 2, 3)</code></pre><p>Now, suppose you get such chromosome or chromosomes and apply a quick local search procedure on them. It may be useful to reinsert such new solutions in the BRKGA population for the next evolutionary cycles. You can do that using <a href="../api/#BrkgaMpIpr.inject_chromosome!"><code>inject_chromosome!</code></a>.</p><pre><code class="language-julia">inject_chromosome!(brkga_data::BrkgaData,
                   chromosome::Array{Float64, 1},
                   population_index::Int64,
                   position::Int64,
                   fitness::Float64 = Inf)</code></pre><p>Note that the chromosome is put in a specific position of a given population. If you do not provide the fitness, <a href="../api/#BrkgaMpIpr.inject_chromosome!"><code>inject_chromosome!</code></a> will decode the injected chromosome. For example, the following code injects a random chromosome <code>keys</code> into the population #1 in the last position (<code>population_size</code>), i.e., it will replace the worst solution:</p><pre><code class="language-julia">keys = sort(rand(instance.num_nodes))
inject_chromosome!(brkga_data, keys, 1, brkga_data.params.population_size)</code></pre><h2><a class="nav-anchor" id="Implicit-Path-Relink-1" href="#Implicit-Path-Relink-1">Implicit Path Relink</a></h2><p>The Implicit Path Relinking (IPR) is a nice addition to the standard BRKGA framework, and it provides an excellent way to create hybrid heuristics and push the optimization further. The good thing about IPR is that you do not need to worry about the path relink implementation, which can be long and tedious if done by hand or customized per problem.</p><p>BrkgaMpIpr provides a friendly interface to use IPR directly from the BRKGA population, and you only must provide a few functions and arguments to have a Path Relink algorithm ready to go. This is the main signature of <a href="../api/#BrkgaMpIpr.path_relink!"><code>path_relink!</code></a></p><pre><code class="language-julia">path_relink!(brkga_data::BrkgaData,
             pr_type::PathRelinkingType,
             pr_selection::PathRelinkingSelection,
             compute_distance::Function,
             affect_solution::Function,
             number_pairs::Int64,
             minimum_distance::Float64,
             block_size::Int64 = 1,
             max_time::Float64 = 0.0,
             percentage::Float64 = 1.0
)::PathRelinkingResult</code></pre><p>The first argument is the <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> as usual. The 2nd argument defines the type of implicit path relink to be performed (<a href="../api/#BrkgaMpIpr.PathRelinkingType"><code>PathRelinkingType</code></a>). The <code>DIRECT</code> path relink exchanges the keys of two chromosomes directly, and it is usually more suitable to or threshold representations, i.e., where the key values are used to some kind of discretization, such as &quot; if x &lt; 0.5, then 0, otherwise 1.&quot; The <code>PERMUTATION</code> path relink switches the order of a key according to its position in the other chromosome. Usually, this kind of path relink is more suitable to permutation representations, where the chromosome induces an order or permutation. For example, chromosome <code>[0.4, 0.7, 0.1]</code> may induce the increasing order <code>(3, 1, 2)</code>. More details about threshold and permutation representations in <a href="http://dx.doi.org/xxx">this paper</a>.</p><p><a href="../api/#BrkgaMpIpr.PathRelinkingSelection"><code>PathRelinkingSelection</code></a> defines how the algorithm picks the chromosomes for relinking. <code>BESTSOLUTION</code> selects, in the order, the best solution of each population. <code>RANDOMELITE</code> chooses uniformly random solutions from the elite sets.</p><p>The next argument is a function to compute the distance between two chromosomes such signature must be</p><pre><code class="language-julia">compute_distance(vector1::Array{Float64, 1},
                 vector2::Array{Float64, 1})::Float64</code></pre><p>If the value returned by <code>compute_distance()</code> is greater than or equal to <code>minimum_distance</code>, the algorithm will perform the path relink between the two chromosomes. Otherwise, it will look for another pair of chromosomes. The algorithm will try <code>number_pairs</code> chromosomes before gives up. In the presence of multiple populations, the path relinking is performed between elite chromosomes from different populations, in a circular fashion. For example, suppose we have 3 populations. The framework performs 3 path relinkings: the first between individuals from populations 1 and 2, the second between populations 2 and 3, and the third between populations 3 and 1. In the case of just one population, both base and guiding individuals are sampled from the elite set of that population.</p><p>Note that in traditional path relink algorithms, <code>compute_distance()</code> depends on the problem structure. On IPR, you can use a generic distance function, or provide one that incorporates more knowledge about the problem. BrkgaMpIpr provides a function to compute the (modified) <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a> for threshold representations (<a href="../api/#BrkgaMpIpr.hamming_distance"><code>hamming_distance</code></a>), and a function that computes the <a href="https://en.wikipedia.org/wiki/Kendall_tau_distance">Kendall Tau distance</a> distance for permutation representations (<a href="../api/#BrkgaMpIpr.kendall_tau_distance"><code>kendall_tau_distance</code></a>). Again, details about threshold and permutation representations in <a href="http://dx.doi.org/xxx">this paper</a>.</p><p>As a simple example, suppose you are using a threshold representation where each chromosome key can represent one of 3 different values (a ternary threshold representation). So, one possible way to compute the distance between two chromosomes can be:</p><pre><code class="language-julia">function value(key::Float64)::Float64
    return key &lt; 0.33 ? 0.0 : (key &lt; 0.66 ? 1.0 : 2.0)
end

function compute_distance(vector1::Array{Float64, 1},
                          vector2::Array{Float64, 1})::Float64
    total = 0.0
    for i in 1:length(vector1)
        total += abs(value(vector1[i]) - value(vector2[i]))
    end
    return total
end</code></pre><p>To avoid changes that do not lead to new solutions, we must verify if such key exchanges affect the solution. For that, we must pass a function with the signature:</p><pre><code class="language-julia">affect_solution(block1::SubArray{Float64, 1},
                block2::SubArray{Float64, 1})::Bool</code></pre><p><code>affect_solution</code> two gets partial chromosomes/block of genes <code>block1</code> and <code>block2</code> and checks whether changing the keys from <code>block1</code> to <code>block2</code> affects the solution. For instance, suppose that the alleles/keys are used as threshold such that values &gt; 0.5 activate a feature. Suppose we have <code>block1 = [0.3, 0.4, 0.1]</code> and <code>block2 = [0.4, 0.1, 0.2]</code>. Since all values are below 0.5, changing the keys from <code>block1</code> to <code>block2</code> do not change the solution, and therefore, we can drop such change (and subsequently decoding). The blocks can hold only one key/allele, sequential key blocks, or even the whole chromosome. Note that <code>affect_solution</code> is crucial to the IPR performance since this function helps to avoid exploring regions already surveyed. Also, note that <code>affect_solution</code> can incorporate some problem knowledge.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>The current implementation of permutation path relink does not make use of <code>affect_solution</code>. However, <a href="../api/#BrkgaMpIpr.path_relink!"><code>path_relink!</code></a> requires the function. You can use the simple lambda function for this one:</p><pre><code class="language-julia">(x, y) -&gt; true</code></pre></div></div><p><code>block_size</code> defines the number of keys / size of the chromosome block to be exchanged during the direct path relink. This parameter is also critical for IPR performance since it avoids too many exchanges during the path building. Usually, we can compute this number based on the size of the chromosome by some factor (<code>alpha_block_size</code> in the configuration file), chosen by you. Again, details here.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Experiments have shown that a good choice is</p><p><span>$block\_size = alpha\_block\_size \times \sqrt{size~of~chromosome}$</span></p></div></div><p>The last two parameters are stopping criteria. The algorithm stops either when <code>max_time</code> seconds is reached or <code>percentage</code>% of the path is built.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>IPR is a very time-intensive process. You must set the stopping criteria accordingly.</p></div></div><p>Let&#39;s see the example on <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_complete.jl"><code>main_complete.jl</code></a>. Remember, since we are solving the TSP, we want to use the permutation-based IPR, and the Kendall Tau distance functions.</p><pre><code class="language-julia">result = path_relink!(
    brkga_data,
    brkga_params.pr_type,
    brkga_params.pr_selection,
    kendall_tau_distance,
    affect_solution_kendall_tau,
    brkga_params.pr_number_pairs,
    brkga_params.pr_minimum_distance,
    1, #block_size doesn&#39;t not matter for permutation.
    maximum_time - (time() - start_time),
    brkga_params.pr_percentage
)</code></pre><p>Note that most parameters come from <a href="../api/#BrkgaMpIpr.BrkgaParams"><code>BrkgaParams</code></a>. The maximum IPR time is set to the remaining time for optimization (global <code>maximum_time</code> minus the elapsed time <code>time() - start_time</code>.</p><p><a href="../api/#BrkgaMpIpr.path_relink!"><code>path_relink!</code></a> returns a <a href="../api/#BrkgaMpIpr.PathRelinkingResult"><code>PathRelinkingResult</code></a> object which defines the status of the IPR optimization. These status are described on <a href="../api/#BrkgaMpIpr.PathRelinkingResult"><code>PathRelinkingResult</code></a>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The <code>TOO_HOMOGENEOUS</code> status is directly linked to the chosen distance function and minimum distance. If the minimum distance is too large, IPR may not be able to find a pair of chromosomes far enough for path relink.</p></div></div><p>If the found solution is the best solution found so far, IPR replaces the worst solution by it. Otherwise, IPR computes the distance between the found solution and all other solutions in the elite set, and replaces the worst solution by it if and only if the found solution is, at least, <code>minimum_distance</code> from all them.</p><h3><a class="nav-anchor" id="Important-notes-about-IPR-1" href="#Important-notes-about-IPR-1">Important notes about IPR</a></h3><p>The API will call <code>decode!()</code> function always with <code>writeback = false</code>. The reason is that if the decoder rewrites the chromosome, the path between solutions is lost and inadvertent results may come up. Note that at the end of the path relinking, the method calls the decoder with <code>writeback = true</code> in the best chromosome found to guarantee that this chromosome is re-written to reflect the best solution found.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Make sure your decoder does not rewrite the chromosome when called with the argument <code>writeback = false</code>.</p></div></div><p>BrkgaMpIpr <a href="../api/#BrkgaMpIpr.path_relink!"><code>path_relink!</code></a> implementation is multi-threaded. Instead of to build and decode each chromosome one at a time, the method builds a list of candidates, altering the alleles/keys according to the guide solution, and then decode all candidates in parallel. Note that <span>$O(chromosome\_size^2 ~/~ block\_size)$</span> additional memory is necessary to build the candidates, which can be costly if the <code>chromosome_size</code> is very large.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>As it is in <a href="../api/#BrkgaMpIpr.evolve!"><code>evolve!()</code></a>, the decoding is done in parallel using threads, and the user <strong>must guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be held, we suggest using single thread by setting the environmental variable <code>JULIA_NUM_THREADS = 1</code> <a href="https://docs.julialang.org/en/v1/manual/parallel-computing">(see Julia Parallel Computing)</a>.</p></div></div><h2><a class="nav-anchor" id="Shaking-and-Resetting-1" href="#Shaking-and-Resetting-1">Shaking and Resetting</a></h2><p>Sometimes, BRKGA gets stuck, converging to local maxima/minima, for several iterations. When such a situation happens, it is a good idea to perturb the population, or even restart from a new one completely new. BrkgaMpIpr offers <a href="../api/#BrkgaMpIpr.shake!"><code>shake!</code></a> function, an improved variation of the original version proposed in <a href="http://dx.doi.org/10.1016/j.eswa.2019.03.007">this paper</a>.</p><pre><code class="language-julia">shake!(brkga_data::BrkgaData,
       intensity::Int64,
       shaking_type::ShakingType,
       population_index::Int64 = Inf64)</code></pre><p><a href="../api/#BrkgaMpIpr.shake!"><code>shake!</code></a> function gets an <code>intensity</code> parameter that measures how many times the perturbation is applied on the elite set for a given <code>population_index</code> (if not given, all populations are shaken). This method offers two generic/implicit <a href="../api/#BrkgaMpIpr.ShakingType"><code>ShakingType</code></a>s. With <a href="../api/#BrkgaMpIpr.ShakingType"><code>CHANGE</code></a>, direct modifications are done in the keys/alleles. This kind of shaking is recommended when the chromosome uses direct or threshold representations. <a href="../api/#BrkgaMpIpr.ShakingType"><code>SWAP</code></a> exchanges keys/alleles inducing new permutations. For representational definitions, please read <a href="http://dx.doi.org/xxx">this paper</a>. For instance, the following code shakes all populations using 10 swap moves.</p><pre><code class="language-julia">shake!(brkga_data, 10, SWAP)</code></pre><p>Sometimes, even shaking the populations does not help to escape from local maxima/minima. So, we need a drastic measure, restarting from scratch the role population. This can be easily accomplished with <a href="../api/#BrkgaMpIpr.reset!"><code>reset!</code></a>.</p><pre><code class="language-julia">reset!(brkga_data)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>When using <a href="../api/#BrkgaMpIpr.reset!"><code>reset!</code></a>, all warm-start solutions provided by <a href="../api/#BrkgaMpIpr.set_initial_population!"><code>set_initial_population!</code></a> are discarded. You may use <a href="../api/#BrkgaMpIpr.inject_chromosome!"><code>inject_chromosome!</code></a> to insert those solutions again.</p></div></div><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Again, the decoding of each chromosome is done in parallel if multi-thread is enabled. Therefore, <strong>we must guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be held, we suggest using a single thread by setting the environmental variable <code>JULIA_NUM_THREADS = 1</code> <a href="https://docs.julialang.org/en/v1/manual/parallel-computing">(see Julia Parallel Computing)</a>.</p></div></div><h2><a class="nav-anchor" id="Multi-population-and-migration-1" href="#Multi-population-and-migration-1">Multi-population and migration</a></h2><p>Multi-population or <em>island model</em> was introduced in genetic algorithms in <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.7225">this paper</a>. The idea is to evolve parallel and independent populations and, once a while, exchange individuals among these populations. In several scenarios, this approach is very beneficial for optimization.</p><p>BrkgaMpIpr is implemented using such island idea from the core. If you read the guide until here, you may notice that several methods take into account multiple populations. To use multiple populations, you must set <a href="../api/#BrkgaMpIpr.BrkgaParams"><code>BrkgaParams</code></a><code>.num_independent_populations</code> with 2 ou more populations, and build <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> from such parameters.</p><p>The immigration process is implemented by</p><pre><code class="language-julia">exchange_elite!(brkga_data::BrkgaData, num_immigrants::Int64)</code></pre><p><a href="../api/#BrkgaMpIpr.exchange_elite!"><code>exchange_elite!</code></a> copies <code>num_immigrants</code> from one population to another, replacing the worst <code>num_immigrants</code> individuals from the recipient population. Note that the migration is done for all pairs of populations. For instance, the following code exchanges 3 best individuals from each population:</p><pre><code class="language-julia">exchange_elite!(brkga_data, 3)</code></pre><h2><a class="nav-anchor" id="Simulating-the-standard-BRKGA-1" href="#Simulating-the-standard-BRKGA-1">Simulating the standard BRKGA</a></h2><p>Sometimes, it is a good idea to test how the standard BRKGA algorithm performs for a problem. You can use BrkgaMpIpr framework to quickly implement and test a standard BRKGA.</p><p>First, you must guarantee that, during the crossover, the algorithm chooses only one elite individual and only one non-elite individual. This is easily accomplished setting <code>num_elite_parents = 1</code> and <code>total_parents = 2</code>. Then, you must set up a bias function that ranks the elite and no-elite individual according to the original BRKGA bias parameter <span>$\rho$</span> (rho).</p><p>You can use <a href="../api/#BrkgaMpIpr.set_bias_custom_function!"><code>set_bias_custom_function!</code></a> for that task. The given function receives the index of the chromosome and returns a ranking for it. Such ranking is used in the roulette method to choose the individual from which each allele comes to build the new chromosome. Since we have one two individuals for crossover in the standard BRKGA, the bias function must return the probability to one or other individual. In the following code, we do that with a simple <code>if...else</code> lambda function.</p><pre><code class="language-julia"># create brkga_params by hand or reading from a file,
# then set the following by hand.
brkga_params.num_elite_parents = 1
brkga_params.total_parents = 2

rho = 0.75
set_bias_custom_function!(brkga_data, x -&gt; x == 1 ? rho : 1.0 - rho)
initialize!(brkga_data)</code></pre><p>Here, we first set the <code>num_elite_parents = 1</code> and <code>total_parents = 2</code> as explained before. Following, we set a variable <code>rho = 0.75</code>. This is the <span>$\rho$</span> from standard BRKGA, and you may set it as you wish. Then, we set the bias function as a very simple lambda function:</p><pre><code class="language-julia">x -&gt; x == 1 ? rho : 1.0 - rho</code></pre><p>So, if the index of the chromosome is 1 (elite individual), it gets a 0.75 rank/probability. If the index is 2 (non-elite individual), the chromosome gets 0.25 rank/probability.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>All these operations must be done before calling <a href="../api/#BrkgaMpIpr.initialize!"><code>initialize!</code></a>.</p></div></div><h2><a class="nav-anchor" id="Reading-and-writing-parameters-1" href="#Reading-and-writing-parameters-1">Reading and writing parameters</a></h2><p>Although we can build a <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> by set up a BrkgaParams object manually, the easiest way to do so is to read such parameters from a configuration file. For this, we can use <a href="../api/#BrkgaMpIpr.load_configuration"><code>load_configuration</code></a> that reads a simple plain text file and returns a tuple of <a href="../api/#BrkgaMpIpr.BrkgaParams"><code>BrkgaParams</code></a> and <a href="../api/#BrkgaMpIpr.ExternalControlParams"><code>ExternalControlParams</code></a> objects. For instance,</p><pre><code class="language-julia">brkga_params, control_params = load_configuration(&quot;tuned_conf.txt&quot;)</code></pre><p>The configuration file must be plain text such that contains pairs of parameter name and value. This file must list all fields from <a href="../api/#BrkgaMpIpr.BrkgaParams"><code>BrkgaParams</code></a> and <a href="../api/#BrkgaMpIpr.ExternalControlParams"><code>ExternalControlParams</code></a>, even though you do not use each one. In <a href="https://github.com/ceandrade/BrkgaMpIpr/tree/v1.0/examples"><code>examples folder</code></a> we have <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/config.conf"><code>config.conf</code></a> that looks like this:</p><pre><code class="language-txt">population_size 2000
elite_percentage 0.30
mutants_percentage 0.15
num_elite_parents 2
total_parents 3
bias_type LOGINVERSE
num_independent_populations 3
pr_number_pairs 0
pr_minimum_distance 0.15
pr_type PERMUTATION
pr_selection BESTSOLUTION
alpha_block_size 1.0
pr_percentage 1.0
exchange_interval 200
num_exchange_indivuduals 2
reset_interval 600</code></pre><p>It does not matter whether we use lower or upper cases. Blank lines and lines starting with <strong>#</strong> are ignored. The order of the parameters should not matter either. And, finally, this file should be readble for both C++ and Julia framework versions.</p><p>In some cases, you define some of the parameters at the running time, and you may want to save them for debug or posterior use. To do so, you can use <a href="../api/#BrkgaMpIpr.write_configuration"><code>write_configuration</code></a>, call upon a <a href="../api/#BrkgaMpIpr.BrkgaParams"><code>BrkgaParams</code></a> object or <a href="../api/#BrkgaMpIpr.BrkgaData"><code>BrkgaData</code></a> object. For example,</p><pre><code class="language-julia">write_configuration(&quot;my_new_parameters.conf&quot;, brkga_params, external_params)
# or
write_configuration(&quot;crazy_parameters.txt&quot;, brkga_data)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><a href="../api/#BrkgaMpIpr.write_configuration"><code>write_configuration</code></a> rewrites the given file. So, watch out to not lose previous configurations.</p></div></div><h2><a class="nav-anchor" id="(Probable-Valuable)-Tips-1" href="#(Probable-Valuable)-Tips-1">(Probable Valuable) Tips</a></h2><h3><a class="nav-anchor" id="Algorithm-warmup-1" href="#Algorithm-warmup-1">Algorithm warmup</a></h3><p>When using Julia code, it is an excellent idea to dry-run all functions you may use and, mainly, want to time. The reason is that Julia uses lazy evaluation when live-compiling the code, i.e., it compiles as it goes. Another advantage is the memory location effects of our data (principle of locality), that can be brought closer to the processor (L2/L3 caches) during the running. Obliviously, this depends on how you implement and use your data structures.</p><p>In <a href="https://github.com/ceandrade/BrkgaMpIpr/blob/v1.0/examples/tsp/main_complete.jl"><code>main_complete.jl</code></a>, we have the following piece of code to warmup mainly the decoder and other functions. Note that we just deep-copy <code>brkga_data</code>, and then, we may lose the principle of locality.</p><pre><code class="language-julia">bogus_data = deepcopy(brkga_data)
evolve!(bogus_data, 2)
path_relink!(bogus_data, brkga_params.pr_type, brkga_params.pr_selection,
             (x, y) -&gt; 1.0, (x, y) -&gt; true, 0, 0.5, 1, 10.0, 1.0)
get_best_fitness(brkga_data)
get_best_chromosome(brkga_data)
bogus_data = nothing</code></pre><h3><a class="nav-anchor" id="Complex-decoders-and-timing-1" href="#Complex-decoders-and-timing-1">Complex decoders and timing</a></h3><p>Some problems require complex decoders while for others, the decoder contains local search procedures, that can be time-consuming. In general, the decoding is the most time-expensive component of a BRKGA algorithm, and it may skew some stopping criteria based on running time. Therefore, if your decoder is time-consuming, it is a good idea to implement a timer or chronometer kind of thing inside the decoder.</p><p>Testing for stopping time uses several CPU cycles, and you need to be careful when/where to test it, otherwise, you spend all the optimization time doing system calls to the clock.</p><p>IMHO, the most effective way to do it is to test time at the very end of the decoding. If the current time is larger than the maximum time allowed, simple return <code>Inf</code> or <code>-Inf</code> according to your optimization direction. In this way, we make the solution <strong>invalid</strong> since it violates the maximum time allowed. The BRKGA framework takes care of the rest.</p><h3><a class="nav-anchor" id="Multi-threading-1" href="#Multi-threading-1">Multi-threading</a></h3><p>Since <a href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore&#39;s law</a> is not holding its status anymore, we, simple mortals, must appeal to the wonders of multi-threading. This paradigm can be tricky to code, and <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl&#39;s law</a> plays against us. Several genetic algorithms, and in particular, BRKGA, can use parallel solution evaluation (or decoding), which makes the use of multi-threading relatively straightforward. BrkgaMpIpr is not different, and it uses <a href="https://docs.julialang.org/en/v1/manual/parallel-computing">Julia multi-threading</a> capabilities to do so.</p><p>First, as commented several times in this guide, <strong>the decoder must be THREAD-SAFE.</strong> So, each thread must have its own read/write data structures and may share other read-only data. The simplest way to do it is to create those structures inside the decoder (like most people do). <strong>But be aware</strong>, this strategy slows down the algorithm significantly depending on the size and format of the structures, and <em>I do not recommend it</em>.</p><p>IMHO, the best way to do that is to preallocate the data structure per thread (using <a href="https://docs.julialang.org/en/v1/base/multi-threading/#Base.Threads.nthreads"><code>Threads.nthreads()</code></a>), and pass them to the decoder through the problem instance. Then, inside the decoder, you can use <a href="https://docs.julialang.org/en/v1/base/multi-threading/#Base.Threads.threadid"><code>Threads.threadid()</code></a> and recover the memory you want to use.</p><p>Let&#39;s see a simple example considering the TSP example. <code>tsp_decode!</code> uses a single array to create the permutation of nodes. Let&#39;s pre-allocate its memory per thread. So, in <code>TSP_Instance</code>, we pre-allocate copies of such array, one for each thread:</p><pre><code class="language-julia">using Base.Threads

# Declare as a type to make the code shorter and more readable.
PermutationArray = Array{Tuple{Float64, Int64}, 1}

struct TSP_Instance &lt;: AbstractInstance
    num_nodes::Int64
    distances::Array{Float64}

    # Permutations arrays per thread, to be pre-allocated.
    permutation_per_thread::Array{PermutationArray, 1}

    function TSP_Instance(filename::String)
        #... Code for loading here

        # Allocate the main array to create references for other arrays per thread.
        permutation_per_thread = Array{PermutationArray, 1}(undef, nthreads())

        # Pre-allocate the permutation arrays, one for each thread.
        for i in 1:nthreads()
            permutation_per_thread[i] = PermutationArray(undef, num_nodes)
        end

        new(num_nodes, distances, permutation_per_thread)
    end
end</code></pre><p>Then, in <code>tsp_decode!</code>, we simply refer to the array according to the local thread ID:</p><pre><code class="language-julia">function tsp_decode!(chromosome::Array{Float64}, instance::TSP_Instance,
                     rewrite::Bool = true)::Float64
    permutation = instance.permutation_per_thread[threadid()]
    #...
    #...
end</code></pre><p>Note that to pre-allocate decoding structures inside the object holding the instance is not the most elegant and decoupled code we can write. However, to decouple the decoding data from the instance data requires that we pass another data object to the decoder. To do this explicitly, we may get an embroidered API. We could do it implicitly, by creating a Singleton object to hold the decoding data. However, this also reduces (a lot) the clarity and objectivity of the code. In C++ code, this is much easier accomplished by creating a Decoder object that can hold data members as much as methods. Therefore, when creating the Decoder object, we can pre-allocate all data structures we need.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Pre-allocation and multi-threading only make sense for large data structures and time-consuming decoders. Otherwise, the code spends too much time on context switching and system calls.</p></div></div><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../license/"><span class="direction">Next</span><span class="title">License</span></a></footer></article></body></html>
